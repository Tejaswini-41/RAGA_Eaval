
--- Similar PR #246210 ---
File: src/vs/workbench/contrib/chat/browser/chatAttachmentWidgets.ts
Before:
import { Disposable } from '../../../../base/common/lifecycle.js';
import { IChatRequestPasteVariableEntry, IChatRequestVariableEntry, OmittedState } from '../common/chatModel.js';
		return this.currentLanguageModel?.metadata.capabilities?.vision ?? false;
		this.element.ariaLabel = ariaLabel;
		this.element.style.position = 'relative';

		if (ref && URI.isUri(ref)) {
			this.element.style.cursor = 'pointer';
			const clickHandler = () => {
				this.openResource(ref, false, undefined);
			};
			this._register(dom.addDisposableListener(this.element, 'click', clickHandler));
		}

		const pillIcon = dom.$('div.chat-attached-context-pill', {}, dom.$(this.modelSupportsVision() ? 'span.codicon.codicon-file-media' : 'span.codicon.codicon-warning'));
		const textLabel = dom.$('span.chat-attached-context-custom-text', {}, attachment.name);
		this.element.appendChild(pillIcon);
		this.element.appendChild(textLabel);

		const hoverElement = dom.$('div.chat-attached-context-hover');
		hoverElement.setAttribute('aria-label', ariaLabel);

		if (!supportsVision && this.currentLanguageModel) {
			this.element.classList.add('warning');
			hoverElement.textContent = localize('chat.fileAttachmentHover', "{0} does not support this {1} type.", currentLanguageModelName, 'image');
			this._register(this.hoverService.setupDelayedHover(this.element, { content: hoverElement, appearance: { showPointer: true } }));
		} else {
			const buffer = attachment.value as Uint8Array;
			this.createImageElements(buffer, this.element, hoverElement, URI.isUri(ref) ? ref : undefined, attachment.omittedState);
			this._register(this.hoverService.setupDelayedHover(this.element, { content: hoverElement, appearance: { showPointer: true } }));
		}
	private createImageElements(buffer: ArrayBuffer | Uint8Array, widget: HTMLElement, hoverElement: HTMLElement, reference?: URI, omittedState?: OmittedState): void {
		if (omittedState === OmittedState.Partial) {
			this.element.classList.add('partial-warning');
		}
		const existingPill = widget.querySelector('.chat-attached-context-pill');
		if (reference) {
			const urlContainer = dom.$('a.chat-attached-context-url', {}, omittedState === OmittedState.Partial ? localize('chat.imageAttachmentWarning', "This GIF was partially omitted - current frame will be sent.") : reference.toString());
			this._register(dom.addDisposableListener(urlContainer, 'click', () => this.openResource(reference, false, undefined)));
		hoverImage.onload = () => {
			URL.revokeObjectURL(url);
		};

			const existingPill = widget.querySelector('.chat-attached-context-pill');
After:
import { Disposable, DisposableStore, IDisposable } from '../../../../base/common/lifecycle.js';
import { IChatRequestPasteVariableEntry, IChatRequestVariableEntry, INotebookOutputVariableEntry, OmittedState } from '../common/chatModel.js';
import { INotebookService } from '../../notebook/common/notebookService.js';
import { CellUri } from '../../notebook/common/notebookCommon.js';
		return modelSupportsVision(this.currentLanguageModel);
function modelSupportsVision(currentLanguageModel: ILanguageModelChatMetadataAndIdentifier | undefined) {
	return currentLanguageModel?.metadata.capabilities?.vision ?? false;
}

		resource = ref && URI.isUri(ref) ? ref : undefined;
		const clickHandler = () => {
			if (resource) {
				this.openResource(resource, false, undefined);
			}
		};
		const fullName = resource?.toString() || attachment.fullName || attachment.name;
		this._register(createImageElements(resource, attachment.name, fullName, this.element, attachment.value as Uint8Array, this.hoverService, ariaLabel, currentLanguageModelName, clickHandler, this.currentLanguageModel, attachment.omittedState));
}

function createImageElements(resource: URI | undefined, name: string, fullName: string,
	element: HTMLElement,
	buffer: ArrayBuffer | Uint8Array,
	hoverService: IHoverService, ariaLabel: string,
	currentLanguageModelName: string,
	clickHandler: () => void,
	currentLanguageModel?: ILanguageModelChatMetadataAndIdentifier,
	omittedState?: OmittedState): IDisposable {

	const disposable = new DisposableStore();
	if (omittedState === OmittedState.Partial) {
		element.classList.add('partial-warning');
	}

	element.ariaLabel = ariaLabel;
	element.style.position = 'relative';

	if (resource) {
		element.style.cursor = 'pointer';
		disposable.add(dom.addDisposableListener(element, 'click', clickHandler));
	}
	const supportsVision = modelSupportsVision(currentLanguageModel);
	const pillIcon = dom.$('div.chat-attached-context-pill', {}, dom.$(supportsVision ? 'span.codicon.codicon-file-media' : 'span.codicon.codicon-warning'));
	const textLabel = dom.$('span.chat-attached-context-custom-text', {}, name);
	element.appendChild(pillIcon);
	element.appendChild(textLabel);

	const hoverElement = dom.$('div.chat-attached-context-hover');
	hoverElement.setAttribute('aria-label', ariaLabel);

	if (!supportsVision && currentLanguageModel) {
		element.classList.add('warning');
		hoverElement.textContent = localize('chat.fileAttachmentHover', "{0} does not support this {1} type.", currentLanguageModelName, 'image');
		disposable.add(hoverService.setupDelayedHover(element, { content: hoverElement, appearance: { showPointer: true } }));
	} else {
		disposable.add(hoverService.setupDelayedHover(element, { content: hoverElement, appearance: { showPointer: true } }));
		const existingPill = element.querySelector('.chat-attached-context-pill');
		if (resource) {
			const urlContainer = dom.$('a.chat-attached-context-url', {}, omittedState === OmittedState.Partial ? localize('chat.imageAttachmentWarning', "This GIF was partially omitted - current frame will be sent.") : fullName);
			disposable.add(dom.addDisposableListener(urlContainer, 'click', () => clickHandler()));
		hoverImage.onload = () => { URL.revokeObjectURL(url); };
			const existingPill = element.querySelector('.chat-attached-context-pill');
	return disposable;

export class NotebookCellOutputChatAttachmentWidget extends AbstractChatAttachmentWidget {
	constructor(
		resource: URI,
		attachment: INotebookOutputVariableEntry,
		currentLanguageModel: ILanguageModelChatMetadataAndIdentifier | undefined,
		shouldFocusClearButton: boolean,
		container: HTMLElement,
		contextResourceLabels: ResourceLabels,
		hoverDelegate: IHoverDelegate,
		@ICommandService commandService: ICommandService,
		@IOpenerService openerService: IOpenerService,
		@IHoverService private readonly hoverService: IHoverService,
		@ILanguageModelsService private readonly languageModelsService: ILanguageModelsService,
		@INotebookService private readonly notebookService: INotebookService,
		@IInstantiationService private readonly instantiationService: IInstantiationService,
	) {
		super(attachment, shouldFocusClearButton, container, contextResourceLabels, hoverDelegate, currentLanguageModel, commandService, openerService);

		switch (attachment.mimeType) {
			case 'application/vnd.code.notebook.error': {
				this.renderErrorOutput(resource, attachment);
				break;
			}
			case 'image/png':
			case 'image/jpeg':
			case 'image/svg': {
				this.renderImageOutput(resource, attachment);
				break;
			}
			default: {
				this.renderGenericOutput(resource, attachment);
			}
		}

		this.instantiationService.invokeFunction(accessor => {
			this._register(hookUpResourceAttachmentDragAndContextMenu(accessor, this.element, resource));
		});
		this.addResourceOpenHandlers(resource, undefined);
		this.attachClearButton();
	}
	getAriaLabel(attachment: INotebookOutputVariableEntry): string {
		return localize('chat.NotebookImageAttachment', "Attached Notebook output, {0}", attachment.name);
	}
	private renderErrorOutput(resource: URI, attachment: INotebookOutputVariableEntry) {
		const attachmentLabel = attachment.name;
		const withIcon = attachment.icon?.id ? `$(${attachment.icon.id})\u00A0${attachmentLabel}` : attachmentLabel;
		const buffer = this.getOutputItem(resource, attachment)?.data.buffer ?? new Uint8Array();
		let title: string | undefined = undefined;
		try {
			const error = JSON.parse(new TextDecoder().decode(buffer)) as Error;
			if (error.name && error.message) {
				title = `${error.name}: ${error.message}`;
			}
		} catch {
			//
		}
		this.label.setLabel(withIcon, undefined, { title });
		this.element.ariaLabel = this.getAriaLabel(attachment);
	}
	private renderGenericOutput(resource: URI, attachment: INotebookOutputVariableEntry) {
		this.element.ariaLabel = this.getAriaLabel(attachment);
		this.label.setFile(resource, { hidePath: true, fileKind: FileKind.FILE, });
	}
	private renderImageOutput(resource: URI, attachment: INotebookOutputVariableEntry) {
		let ariaLabel: string;
		if (attachment.omittedState === OmittedState.Full) {
			ariaLabel = localize('chat.omittedNotebookImageAttachment', "Omitted this Notebook ouput: {0}", attachment.name);
		} else if (attachment.omittedState === OmittedState.Partial) {
			ariaLabel = localize('chat.partiallyOmittedNotebookImageAttachment', "Partially omitted this Notebook output: {0}", attachment.name);
		} else {
			ariaLabel = this.getAriaLabel(attachment);
		}

		const clickHandler = () => this.openResource(resource, false, undefined);
		const currentLanguageModelName = this.currentLanguageModel ? this.languageModelsService.lookupLanguageModel(this.currentLanguageModel.identifier)?.name ?? this.currentLanguageModel.identifier : 'unknown';
		const buffer = this.getOutputItem(resource, attachment)?.data.buffer ?? new Uint8Array();
		this._register(createImageElements(resource, attachment.name, attachment.name, this.element, buffer, this.hoverService, ariaLabel, currentLanguageModelName, clickHandler, this.currentLanguageModel, attachment.omittedState));
	}

	private getOutputItem(resource: URI, attachment: INotebookOutputVariableEntry) {
		const parsedInfo = CellUri.parseCellOutputUri(resource);
		if (!parsedInfo || typeof parsedInfo.cellHandle !== 'number' || typeof parsedInfo.outputIndex !== 'number') {
			return undefined;
		}
		const notebook = this.notebookService.getNotebookTextModel(parsedInfo.notebook);
		if (!notebook) {
			return undefined;
		}
		const cell = notebook.cells.find(c => c.handle === parsedInfo.cellHandle);
		if (!cell) {
			return undefined;
		}
		const output = cell.outputs.length > parsedInfo.outputIndex ? cell.outputs[parsedInfo.outputIndex] : undefined;
		return output?.outputs.find(o => o.mime === attachment.mimeType);
	}

}

File: src/vs/workbench/contrib/chat/browser/chatContentParts/chatAttachmentsContentPart.ts
Before:
import { IChatRequestVariableEntry, isImageVariableEntry, isPasteVariableEntry, OmittedState } from '../../common/chatModel.js';
			if (resource && (attachment.kind === 'file' || attachment.kind === 'directory')) {
				const fileBasename = basename(resource.path);
				const fileDirname = dirname(resource.path);
				const friendlyName = `${fileBasename} ${fileDirname}`;

				if (isAttachmentOmitted) {
					ariaLabel = range ? localize('chat.omittedFileAttachmentWithRange', "Omitted: {0}, line {1} to line {2}.", friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.omittedFileAttachment', "Omitted: {0}.", friendlyName);
				} else if (isAttachmentPartialOrOmitted) {
					ariaLabel = range ? localize('chat.partialFileAttachmentWithRange', "Partially attached: {0}, line {1} to line {2}.", friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.partialFileAttachment', "Partially attached: {0}.", friendlyName);
				} else {
					ariaLabel = range ? localize('chat.fileAttachmentWithRange3', "Attached: {0}, line {1} to line {2}.", friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment3', "Attached: {0}.", friendlyName);
				}
			} else if (isImageVariableEntry(attachment)) {
				if (attachment.omittedState === OmittedState.Full) {
					ariaLabel = localize('chat.omittedImageAttachment', "Omitted this image: {0}", attachment.name);
				} else if (attachment.omittedState === OmittedState.Partial) {
					ariaLabel = localize('chat.partiallyOmittedImageAttachment', "Partially omitted this image: {0}", attachment.name);
				} else {
					ariaLabel = localize('chat.imageAttachment', "Attached image, {0}", attachment.name);
				}
				const ref = attachment.references?.[0]?.reference;
				if (ref && URI.isUri(ref)) {
						this.openResource(ref, false, undefined);
				const buffer = attachment.value as Uint8Array;
				this.createImageElements(buffer, widget, hoverElement, URI.isUri(ref) ? ref : undefined, omissionType);
				const attachmentLabel = attachment.fullName ?? attachment.name;
				const withIcon = attachment.icon?.id ? `$(${attachment.icon.id}) ${attachmentLabel}` : attachmentLabel;
				label.setLabel(withIcon, correspondingContentReference?.options?.status?.description);

	private createImageElements(buffer: ArrayBuffer | Uint8Array, widget: HTMLElement, hoverElement: HTMLElement, reference?: URI, omittedState?: OmittedState): void {
			const urlContainer = dom.$('a.chat-attached-context-url', {}, omittedState === OmittedState.Partial ? localize('chat.imageAttachmentWarning', "This GIF was partially omitted - current frame was be sent.") : reference.toString());
After:
import { CellUri } from '../../../notebook/common/notebookCommon.js';
import { INotebookService } from '../../../notebook/common/notebookService.js';
import { IChatRequestVariableEntry, INotebookOutputVariableEntry, isImageVariableEntry, isNotebookOutputVariableEntry, isPasteVariableEntry, OmittedState } from '../../common/chatModel.js';
		@INotebookService private readonly notebookService: INotebookService,
			const renderFileAttachment = (ariaLabel: string, friendlyName: string, resource: URI,) => {
			};
			const renderImageAttachment = (ariaLabel: string, resource: URI | undefined, fullName: string, buffer: Uint8Array) => {
				if (resource) {
						this.openResource(resource, false, undefined);
				this.createImageElements(buffer, widget, hoverElement, fullName, resource, omissionType);
			};

			const renderLabelWithIcon = (attachment: IChatRequestVariableEntry) => {
				const attachmentLabel = attachment.fullName ?? attachment.name;
				const withIcon = attachment.icon?.id ? `$(${attachment.icon.id}) ${attachmentLabel}` : attachmentLabel;
				label.setLabel(withIcon, correspondingContentReference?.options?.status?.description);
			};

			if (resource && isNotebookOutputVariableEntry(attachment)) {
				const friendlyName = attachment.name;
				const output = this.getOutputItem(resource, attachment);
				if (output?.mime.startsWith('image/')) {
					if (attachment.omittedState === OmittedState.Full) {
						ariaLabel = localize('chat.notebookOutputOmittedImageAttachment', "Omitted: {0}", friendlyName);
					} else if (attachment.omittedState === OmittedState.Partial) {
						ariaLabel = localize('chat.notebookOutputPartiallyOmittedImageAttachment', "Partially omitted: {0}", friendlyName);
					} else {
						ariaLabel = localize('chat.notebookOutputImageAttachment', "Attached: {0}", friendlyName);
					}
				} else {
					if (isAttachmentOmitted) {
						ariaLabel = localize('chat.notebookOutputOmittedFileAttachment', "Omitted: {0}.", friendlyName);
					} else if (isAttachmentPartialOrOmitted) {
						ariaLabel = localize('chat.notebookOutputPartialFileAttachment', "Partially attached: {0}.", friendlyName);
					} else {
						ariaLabel = localize('chat.notebookOutputFileAttachment3', "Attached: {0}.", friendlyName);
					}
				}

				switch (output?.mime) {
					case 'application/vnd.code.notebook.error': {
						renderLabelWithIcon(attachment);
						break;
					}
					case 'image/png':
					case 'image/jpeg':
					case 'image/svg': {
						renderImageAttachment(ariaLabel, resource, attachment.name, output.data.buffer);
						break;
					}
					default: {
						renderFileAttachment(ariaLabel, attachment.name, resource);
					}
				}

				this.instantiationService.invokeFunction(accessor => {
					if (resource) {
						this.attachedContextDisposables.add(hookUpResourceAttachmentDragAndContextMenu(accessor, widget, resource));
					}
				});
			} else if (resource && (attachment.kind === 'file' || attachment.kind === 'directory')) {
				const fileBasename = basename(resource.path);
				const fileDirname = dirname(resource.path);
				const friendlyName = `${fileBasename} ${fileDirname}`;

				if (isAttachmentOmitted) {
					ariaLabel = range ? localize('chat.omittedFileAttachmentWithRange', "Omitted: {0}, line {1} to line {2}.", friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.omittedFileAttachment', "Omitted: {0}.", friendlyName);
				} else if (isAttachmentPartialOrOmitted) {
					ariaLabel = range ? localize('chat.partialFileAttachmentWithRange', "Partially attached: {0}, line {1} to line {2}.", friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.partialFileAttachment', "Partially attached: {0}.", friendlyName);
				} else {
					ariaLabel = range ? localize('chat.fileAttachmentWithRange3', "Attached: {0}, line {1} to line {2}.", friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment3', "Attached: {0}.", friendlyName);
				}

				renderFileAttachment(ariaLabel, friendlyName, resource);
			} else if (isImageVariableEntry(attachment)) {
				if (attachment.omittedState === OmittedState.Full) {
					ariaLabel = localize('chat.omittedImageAttachment', "Omitted this image: {0}", attachment.name);
				} else if (attachment.omittedState === OmittedState.Partial) {
					ariaLabel = localize('chat.partiallyOmittedImageAttachment', "Partially omitted this image: {0}", attachment.name);
				} else {
					ariaLabel = localize('chat.imageAttachment', "Attached image, {0}", attachment.name);
				}

				const ref = attachment.references?.[0]?.reference;
				const resource = ref && URI.isUri(ref) ? ref : undefined;
				renderImageAttachment(ariaLabel, resource, resource?.toString() ?? '', attachment.value as Uint8Array);
				renderLabelWithIcon(attachment);
	private getOutputItem(resource: URI, attachment: INotebookOutputVariableEntry) {
		const parsedInfo = CellUri.parseCellOutputUri(resource);
		if (!parsedInfo || typeof parsedInfo.cellHandle !== 'number' || typeof parsedInfo.outputIndex !== 'number') {
			return undefined;
		}
		const notebook = this.notebookService.getNotebookTextModel(parsedInfo.notebook);
		if (!notebook) {
			return undefined;
		}
		const cell = notebook.cells.find(c => c.handle === parsedInfo.cellHandle);
		if (!cell) {
			return undefined;
		}
		const output = cell.outputs.length > parsedInfo.outputIndex ? cell.outputs[parsedInfo.outputIndex] : undefined;
		return output?.outputs.find(o => o.mime === attachment.mimeType);
	}

	private createImageElements(buffer: ArrayBuffer | Uint8Array, widget: HTMLElement, hoverElement: HTMLElement, fullName: string, reference?: URI, omittedState?: OmittedState): void {
			const urlContainer = dom.$('a.chat-attached-context-url', {}, omittedState === OmittedState.Partial ? localize('chat.imageAttachmentWarning', "This GIF was partially omitted - current frame was be sent.") : fullName);

File: src/vs/workbench/contrib/chat/browser/chatInputPart.ts
Before:
import { IChatRequestVariableEntry, isImageVariableEntry, isPasteVariableEntry } from '../common/chatModel.js';
import { DefaultChatAttachmentWidget, FileAttachmentWidget, ImageAttachmentWidget, PasteAttachmentWidget } from './chatAttachmentWidgets.js';
			if (resource && (attachment.kind === 'file' || attachment.kind === 'directory')) {
After:
import { IChatRequestVariableEntry, isImageVariableEntry, isNotebookOutputVariableEntry, isPasteVariableEntry } from '../common/chatModel.js';
import { DefaultChatAttachmentWidget, FileAttachmentWidget, ImageAttachmentWidget, NotebookCellOutputChatAttachmentWidget, PasteAttachmentWidget } from './chatAttachmentWidgets.js';
			if (resource && isNotebookOutputVariableEntry(attachment)) {
				attachmentWidget = this.instantiationService.createInstance(NotebookCellOutputChatAttachmentWidget, resource, attachment, this._currentLanguageModel, shouldFocusClearButton, container, this._contextResourceLabels, hoverDelegate);
			} else if (resource && (attachment.kind === 'file' || attachment.kind === 'directory')) {

File: src/vs/workbench/contrib/chat/common/chatModel.ts
Before:
	| IChatRequestDirectoryEntry | IChatRequestFileEntry;
After:
export interface INotebookOutputVariableEntry extends Omit<IBaseChatRequestVariableEntry, 'kind'> {
	readonly kind: 'notebookOutput';
	readonly outputIndex?: number;
	readonly mimeType?: string;
}

	| IChatRequestDirectoryEntry | IChatRequestFileEntry | INotebookOutputVariableEntry;
export function isNotebookOutputVariableEntry(obj: IChatRequestVariableEntry): obj is INotebookOutputVariableEntry {
	return obj.kind === 'notebookOutput';
}


File: src/vs/workbench/contrib/notebook/browser/controller/chat/notebook.chat.contribution.ts
Before:
import { IGenericChatRequestVariableEntry } from '../../../../chat/common/chatModel.js';
			if (!cell) {

			}
			// get URI of notebook
			let notebookUri = notebookEditor.textModel?.uri;
			if (!notebookUri) {
				// if the notebook is not found, try to parse the cell uri
				const parsedCellUri = CellUri.parse(cellUri);
				notebookUri = parsedCellUri?.notebook;
				if (!notebookUri) {
					return;
				}
			}


			const l: IGenericChatRequestVariableEntry = {
				kind: 'generic',
				name: outputCellUri.toString(),
After:
import { INotebookOutputVariableEntry } from '../../../../chat/common/chatModel.js';
import { ThemeIcon } from '../../../../../../base/common/themables.js';
import { normalizeDriveLetter } from '../../../../../../base/common/labels.js';
import { basenameOrAuthority } from '../../../../../../base/common/resources.js';
			const notebookModel = notebookEditor.textModel;
			if (!cell || cell.outputsViewModels.length === 0 || !notebookModel) {
			const notebookUri = notebookModel.uri;
			const cellIndex = notebookModel.cells.indexOf(cell.model);
			}
			const fileName = normalizeDriveLetter(basenameOrAuthority(notebookUri));
			const l: INotebookOutputVariableEntry = {
				name: localize('notebookOutputCellLabel', "{0} • Cell {1} • Output {2}", fileName, `${cellIndex + 1}`, `${outputIndex + 1}`),
				icon: mimeType === 'application/vnd.code.notebook.error' ? ThemeIcon.fromId('error') : undefined,
				kind: 'notebookOutput',
				outputIndex,
				mimeType


--- Similar PR #246211 ---
File: src/vs/editor/browser/editorBrowser.ts
Before:
	setDecorationsByType(description: string, decorationTypeKey: string, ranges: editorCommon.IDecorationOptions[]): void;
After:
	setDecorationsByType(description: string, decorationTypeKey: string, ranges: editorCommon.IDecorationOptions[]): readonly string[];

File: src/vs/editor/browser/widget/codeEditor/codeEditorWidget.ts
Before:
	public setDecorationsByType(description: string, decorationTypeKey: string, decorationOptions: editorCommon.IDecorationOptions[]): void {
After:
	public setDecorationsByType(description: string, decorationTypeKey: string, decorationOptions: editorCommon.IDecorationOptions[]): readonly string[] {
		return this._decorationTypeKeysToIds[decorationTypeKey] || [];

File: src/vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables.ts
Before:
import { Disposable, DisposableStore, isDisposable } from '../../../../../base/common/lifecycle.js';
function changeIsBeforeVariable(changeRange: IRange, variableRange: IRange): boolean {
	return (
		changeRange.endLineNumber < variableRange.startLineNumber ||
		(changeRange.endLineNumber === variableRange.startLineNumber && changeRange.endColumn <= variableRange.startColumn)
	);
}

function changeIsAfterVariable(changeRange: IRange, variableRange: IRange): boolean {
	return (
		changeRange.startLineNumber > variableRange.endLineNumber ||
		(changeRange.startLineNumber === variableRange.endLineNumber && changeRange.startColumn >= variableRange.endColumn)
	);
}

			e.changes.forEach(c => {
				// Don't mutate entries in _variables, since they will be returned from the getter
				this._variables = coalesce(this._variables.map((ref): TDynamicVariable | null => {
					const intersection = Range.intersectRanges(ref.range, c.range);
					if (intersection && !intersection.isEmpty()) {
						// The reference text was changed, it's broken.
						// But if the whole reference range was deleted (eg history navigation) then don't try to change the editor.
						if (!Range.containsRange(c.range, ref.range)) {
							const rangeToDelete = new Range(ref.range.startLineNumber, ref.range.startColumn, ref.range.endLineNumber, ref.range.endColumn - 1);
							this.widget.inputEditor.executeEdits(this.id, [{
								range: rangeToDelete,
								text: '',
							}]);
							this.widget.refreshParsedInput();
						}

						// dispose the reference if possible before dropping it off
						if (isDisposable(ref)) {
							ref.dispose();
						}

						return null;
					} else if (Range.compareRangesUsingStarts(ref.range, c.range) > 0) {
						// Determine if the change is before, after, or overlaps with the variable range.
						if (changeIsBeforeVariable(c.range, ref.range)) {

							// Calculate line delta
							const linesInserted = c.text.split('\n').length - 1;
							const linesRemoved = c.range.endLineNumber - c.range.startLineNumber;
							const lineDelta = linesInserted - linesRemoved;

							// Initialize column delta
							let columnDelta = 0;

							// Check if change is on the same line as the variable start
							if (c.range.endLineNumber === ref.range.startLineNumber) {
								// Change is on the same line
								if (c.range.endColumn <= ref.range.startColumn) {
									// Change occurs before the variable start column
									if (linesInserted === 0) {
										// Single-line change
										const charsInserted = c.text.length;
										const charsRemoved = c.rangeLength;
										columnDelta = charsInserted - charsRemoved;
									} else {
										// Multi-line change (newline inserted)
										columnDelta = - (c.range.endColumn - 1);
										// The variable column should be adjusted to account for the reset after newline
									}
								} else {
									// Change occurs after the variable start column
									columnDelta = 0;
								}
							} else if (c.range.endLineNumber < ref.range.startLineNumber) {
								// Change is on lines before the variable line
								columnDelta = 0;
							}

							const newRange = {
								startLineNumber: ref.range.startLineNumber + lineDelta,
								startColumn: ref.range.startColumn + columnDelta,
								endLineNumber: ref.range.endLineNumber + lineDelta,
								endColumn: ref.range.endColumn + columnDelta
							};
							if (ref instanceof ChatFileReference) {
								ref.range = newRange;
								return ref;
							} else {
								return {
									...ref,
									range: newRange
								};
							}
						} else if (changeIsAfterVariable(c.range, ref.range)) {
							// Change is after the variable no adjustment needed.
							return ref;
						} else {
							// Change overlaps with the variable the variable is broken.
							return null;
						}
					}
				}));
			});
		this.widget.inputEditor.setDecorationsByType('chat', dynamicVariableDecorationType, this._variables.map((r): IDecorationOptions => ({
		})));
After:
import { Disposable, DisposableStore, dispose, isDisposable } from '../../../../../base/common/lifecycle.js';
	private decorationData: { id: string; text: string }[] = [];

			const removed: TDynamicVariable[] = [];
			let didChange = false;

			// Don't mutate entries in _variables, since they will be returned from the getter
			this._variables = coalesce(this._variables.map((ref, idx): TDynamicVariable | null => {
				const model = widget.inputEditor.getModel();

				if (!model) {
					removed.push(ref);
					return null;
				}

				const data = this.decorationData[idx];
				const newRange = model.getDecorationRange(data.id);

				if (!newRange) {
					// gone
					removed.push(ref);
					return null;
				}

				const newText = model.getValueInRange(newRange);
				if (newText !== data.text) {

					this.widget.inputEditor.executeEdits(this.id, [{
						range: newRange,
						text: '',
					}]);
					this.widget.refreshParsedInput();

					removed.push(ref);
					return null;
				}

				if (newRange.equalsRange(ref.range)) {
					// all good
				}

				didChange = true;

				if (ref instanceof ChatFileReference) {
					ref.range = newRange;
					return ref;
				} else {
					return { ...ref, range: newRange };
				}
			}));

			// cleanup disposable variables
			dispose(removed.filter(isDisposable));

			if (didChange || removed.length > 0) {
				this.widget.refreshParsedInput();
			}

		const decorations = this._variables.map((r): IDecorationOptions => ({
		}));
		const decorationIds = this.widget.inputEditor.setDecorationsByType('chat', dynamicVariableDecorationType, decorations);

		this.decorationData = [];
		for (let i = 0; i < decorationIds.length; i++) {
			this.decorationData.push({
				id: decorationIds[i],
				text: this.widget.inputEditor.getModel()!.getValueInRange(this._variables[i].range)
			});
		}

File: src/vs/workbench/contrib/chat/browser/contrib/chatInputEditorContrib.ts
Before:
import { Disposable, MutableDisposable } from '../../../../../base/common/lifecycle.js';
		this._register(this.themeService.onDidColorThemeChange(() => this.updateRegisteredDecorationTypes()));
		this.updateRegisteredDecorationTypes();
	private updateRegisteredDecorationTypes() {
		this.codeEditorService.removeDecorationType(variableTextDecorationType);
		this.codeEditorService.removeDecorationType(dynamicVariableDecorationType);
		this.codeEditorService.removeDecorationType(slashCommandTextDecorationType);
		const theme = this.themeService.getColorTheme();
			color: theme.getColor(chatSlashCommandForeground)?.toString(),
			backgroundColor: theme.getColor(chatSlashCommandBackground)?.toString(),
			color: theme.getColor(chatSlashCommandForeground)?.toString(),
			backgroundColor: theme.getColor(chatSlashCommandBackground)?.toString(),
			color: theme.getColor(chatSlashCommandForeground)?.toString(),
			backgroundColor: theme.getColor(chatSlashCommandBackground)?.toString(),
			borderRadius: '3px'
		this.updateInputEditorDecorations();
After:
import { Disposable, MutableDisposable, toDisposable } from '../../../../../base/common/lifecycle.js';
import { themeColorFromId } from '../../../../../base/common/themables.js';
import { TrackedRangeStickiness } from '../../../../../editor/common/model.js';
		this.registeredDecorationTypes();
	private registeredDecorationTypes() {
			color: themeColorFromId(chatSlashCommandForeground),
			backgroundColor: themeColorFromId(chatSlashCommandBackground),
			color: themeColorFromId(chatSlashCommandForeground),
			backgroundColor: themeColorFromId(chatSlashCommandBackground),
			color: themeColorFromId(chatSlashCommandForeground),
			backgroundColor: themeColorFromId(chatSlashCommandBackground),
			borderRadius: '3px',
			rangeBehavior: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges

		this._register(toDisposable(() => {
			this.codeEditorService.removeDecorationType(variableTextDecorationType);
			this.codeEditorService.removeDecorationType(dynamicVariableDecorationType);
			this.codeEditorService.removeDecorationType(slashCommandTextDecorationType);
		}));


--- Similar PR #246224 ---
File: src/vs/workbench/contrib/chat/browser/actions/chatActions.ts
Before:
				menu: {
				}
After:
import { ctxHasRequestInProgress, ctxIsGlobalEditingSession } from '../chatEditing/chatEditingEditorContextKeys.js';
				menu: [{
				}, {
					id: MenuId.ChatEditingEditorContent,
					when: ContextKeyExpr.and(ctxHasRequestInProgress, ctxIsGlobalEditingSession),
					group: 'navigate',
					order: 4,
				}]

File: src/vs/workbench/contrib/chat/browser/chatEditing/chatEditingEditorOverlay.ts
Before:
	// private readonly _progressNode: HTMLElement;
				if (action.id === 'inlineChat2.reveal' || action.id === 'workbench.action.chat.openEditSession') {

						protected override getTooltip(): string | undefined {
							return this._requestMessage.get()?.message || super.getTooltip();
						}
After:
import { CHAT_OPEN_ACTION_ID } from '../actions/chatActions.js';
				if (action.id === 'inlineChat2.reveal' || action.id === CHAT_OPEN_ACTION_ID) {

File: src/vs/workbench/contrib/inlineChat/browser/inlineChat.contribution.ts
After:
registerAction2(InlineChatActions.CancelRequestAction);

File: src/vs/workbench/contrib/inlineChat/browser/inlineChatActions.ts
Before:
import { ctxIsGlobalEditingSession, ctxRequestCount } from '../../chat/browser/chatEditing/chatEditingEditorContextKeys.js';
After:
import { ctxHasRequestInProgress, ctxIsGlobalEditingSession, ctxRequestCount } from '../../chat/browser/chatEditing/chatEditingEditorContextKeys.js';

export class CancelRequestAction extends AbstractInline2ChatAction {
	constructor() {
		super({
			id: 'inlineChat2.cancelRequest',
			title: localize2('cancel', "Cancel Request"),
			f1: true,
			icon: Codicon.stopCircle,
			precondition: ContextKeyExpr.and(ctxIsGlobalEditingSession.negate(), ctxHasRequestInProgress),
			toggled: CTX_INLINE_CHAT_VISIBLE,
			menu: {
				id: MenuId.ChatEditingEditorContent,
				when: ContextKeyExpr.and(
					ctxHasRequestInProgress,
					ctxIsGlobalEditingSession.negate(),
				),
				group: 'navigate',
				order: 14,
			}
		});
	}

	runInlineChatCommand(accessor: ServicesAccessor, ctrl: InlineChatController2, _editor: ICodeEditor): void {
		const chatService = accessor.get(IChatService);

		const { viewModel } = ctrl.widget.chatWidget;
		if (viewModel) {
			ctrl.toggleWidgetUntilNextRequest();
			ctrl.markActiveController();
			chatService.cancelCurrentRequestForSession(viewModel.sessionId);
		}
	}
}

