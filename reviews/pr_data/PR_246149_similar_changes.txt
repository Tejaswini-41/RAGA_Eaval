
--- Similar PR #246224 ---
File: src/vs/workbench/contrib/chat/browser/actions/chatActions.ts
Before:
				menu: {
				}
After:
import { ctxHasRequestInProgress, ctxIsGlobalEditingSession } from '../chatEditing/chatEditingEditorContextKeys.js';
				menu: [{
				}, {
					id: MenuId.ChatEditingEditorContent,
					when: ContextKeyExpr.and(ctxHasRequestInProgress, ctxIsGlobalEditingSession),
					group: 'navigate',
					order: 4,
				}]

File: src/vs/workbench/contrib/chat/browser/chatEditing/chatEditingEditorOverlay.ts
Before:
	// private readonly _progressNode: HTMLElement;
				if (action.id === 'inlineChat2.reveal' || action.id === 'workbench.action.chat.openEditSession') {

						protected override getTooltip(): string | undefined {
							return this._requestMessage.get()?.message || super.getTooltip();
						}
After:
import { CHAT_OPEN_ACTION_ID } from '../actions/chatActions.js';
				if (action.id === 'inlineChat2.reveal' || action.id === CHAT_OPEN_ACTION_ID) {

File: src/vs/workbench/contrib/inlineChat/browser/inlineChat.contribution.ts
After:
registerAction2(InlineChatActions.CancelRequestAction);

File: src/vs/workbench/contrib/inlineChat/browser/inlineChatActions.ts
Before:
import { ctxIsGlobalEditingSession, ctxRequestCount } from '../../chat/browser/chatEditing/chatEditingEditorContextKeys.js';
After:
import { ctxHasRequestInProgress, ctxIsGlobalEditingSession, ctxRequestCount } from '../../chat/browser/chatEditing/chatEditingEditorContextKeys.js';

export class CancelRequestAction extends AbstractInline2ChatAction {
	constructor() {
		super({
			id: 'inlineChat2.cancelRequest',
			title: localize2('cancel', "Cancel Request"),
			f1: true,
			icon: Codicon.stopCircle,
			precondition: ContextKeyExpr.and(ctxIsGlobalEditingSession.negate(), ctxHasRequestInProgress),
			toggled: CTX_INLINE_CHAT_VISIBLE,
			menu: {
				id: MenuId.ChatEditingEditorContent,
				when: ContextKeyExpr.and(
					ctxHasRequestInProgress,
					ctxIsGlobalEditingSession.negate(),
				),
				group: 'navigate',
			...[truncated]
--- Similar PR #246215 ---
File: src/vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables.ts
Before:
import { timeout } from '../../../../../base/common/async.js';
import { Command, isLocation, SymbolKinds } from '../../../../../editor/common/languages.js';
import { ITextModelService } from '../../../../../editor/common/services/resolverService.js';
import { ISymbolQuickPickItem } from '../../../search/browser/symbolsQuickAccess.js';
export class SelectAndInsertFileAction extends Action2 {
	static readonly Name = 'files';
	static readonly Item = {
		label: localize('allFiles', 'All Files'),
		description: localize('allFilesDescription', 'Search for relevant files in the workspace and provide context from them'),
	};
	static readonly ID = 'workbench.action.chat.selectAndInsertFile';

	constructor() {
		super({
			id: SelectAndInsertFileAction.ID,
			title: '' // not displayed
		});
	}

	async run(accessor: ServicesAccessor, ...args: any[]) {
		const textModelService = accessor.get(ITextModelService);
		const logService = accessor.get(ILogService);
		const quickInputService = accessor.get(IQuickInputService);

		const context = args[0];
		if (!isSelectAndInsertActionContext(context)) {
			return;
		}

		const doCleanup = () => {
			// Failed, remove the dangling `file`
			context.widget.inputEditor.executeEdits('chatInsertFile', [{ range: context.range, text: `` }]);
		};

		// TODO: have dedicated UX for this instead of using the quick access picker
		await timeout(0); // https://github.com/microsoft/vscode/issues/243115
		const picks = await quickInputService.quickAccess.pick('');
		if (!picks?.length) {
			logService.trace('SelectAndInsertFileAction: no file selected');
			doCleanup();
			return;
		}

		const editor = context.widget.inputEditor;
		const range = context.range;

		// Handle the special case of selecting all files
		if (picks[0] === SelectAndInsertFileAction.Item) {
			const text = `#${SelectAndInsertFileAction.Name}`;
			const success = editor.executeEdits('chatInser...[truncated]
--- Similar PR #246211 ---
File: src/vs/editor/browser/editorBrowser.ts
Before:
	setDecorationsByType(description: string, decorationTypeKey: string, ranges: editorCommon.IDecorationOptions[]): void;
After:
	setDecorationsByType(description: string, decorationTypeKey: string, ranges: editorCommon.IDecorationOptions[]): readonly string[];

File: src/vs/editor/browser/widget/codeEditor/codeEditorWidget.ts
Before:
	public setDecorationsByType(description: string, decorationTypeKey: string, decorationOptions: editorCommon.IDecorationOptions[]): void {
After:
	public setDecorationsByType(description: string, decorationTypeKey: string, decorationOptions: editorCommon.IDecorationOptions[]): readonly string[] {
		return this._decorationTypeKeysToIds[decorationTypeKey] || [];

File: src/vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables.ts
Before:
import { Disposable, DisposableStore, isDisposable } from '../../../../../base/common/lifecycle.js';
function changeIsBeforeVariable(changeRange: IRange, variableRange: IRange): boolean {
	return (
		changeRange.endLineNumber < variableRange.startLineNumber ||
		(changeRange.endLineNumber === variableRange.startLineNumber && changeRange.endColumn <= variableRange.startColumn)
	);
}

function changeIsAfterVariable(changeRange: IRange, variableRange: IRange): boolean {
	return (
		changeRange.startLineNumber > variableRange.endLineNumber ||
		(changeRange.startLineNumber === variableRange.endLineNumber && changeRange.startColumn >= variableRange.endColumn)
	);
}

			e.changes.forEach(c => {
				// Don't mutate entries in _variables, since they will be returned from the getter
				this._variables = coalesce(this._variables.map((ref): TDynamicVariable | null => {
					const intersection = Range.intersectRanges(ref.range, c.range);
					if (intersection && !intersection.isEmpty()) {
						// The reference text was changed, it's broken.
						// But if the whole reference range was deleted (eg history navigation) then don't try to change the editor.
		...[truncated]