
--- Similar PR #249473 ---
File: src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts
Before:
import { Button } from '../../../../../base/browser/ui/button/button.js';
import { getDefaultHoverDelegate } from '../../../../../base/browser/ui/hover/hoverDelegateFactory.js';
import { IHoverService } from '../../../../../platform/hover/browser/hover.js';
		@IHoverService private readonly hoverService: IHoverService,
		this.domNode.classList.toggle('disabled', !this.attachment.enabled);
		const range = URI.isUri(this.attachment.value) || !this.attachment.isSelection ? undefined : this.attachment.value!.range;
		const ariaLabel = range ? localize('chat.fileAttachmentWithRange', "Attached {0}, {1}, line {2} to line {3}", attachmentTypeName, friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment', "Attached {0}, {1}", attachmentTypeName, friendlyName);
		const hintLabel = localize('hint.label.current', "Current {0}", attachmentTypeName);
		const hintElement = dom.append(this.domNode, dom.$('span.chat-implicit-hint', undefined, hintLabel));
		this._register(this.hoverService.setupManagedHover(getDefaultHoverDelegate('element'), hintElement, title));

		const buttonMsg = this.attachment.enabled ? localize('disable', "Disable current {0} context", attachmentTypeName) : localize('enable', "Enable current {0} context", attachmentTypeName);
		const toggleButton = this.renderDisposables.add(new Button(this.domNode, { supportIcons: true, title: buttonMsg }));
		toggleButton.icon = this.attachment.enabled ? Codicon.eye : Codicon.eyeClosed;
		this.renderDisposables.add(toggleButton.onDidClick((e) => {
			e.stopPropagation(); // prevent it from triggering the click handler on the parent immediately after rerendering
			this.attachment.enabled = !this.attachment.enabled;
After:
import { ChatAttachmentModel } from '../chatAttachmentModel.js';
		private readonly attachmentModel: ChatAttachmentModel,
		this.domNode.classList.add('disabled');
		const range ...[truncated]
--- Similar PR #249497 ---
File: src/vs/workbench/api/common/extHostLanguageModelTools.ts
Before:
					title: result.confirmationMessages.title,
					title: result.confirmationMessages.title,
After:
					title: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),
					title: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),

File: src/vs/workbench/contrib/chat/browser/chatAccessibilityProvider.ts
Before:
					toolInvocationHint += localize('toolCompletedHint', "Tool {0} completed.", invocation.confirmationMessages?.title);
After:
					toolInvocationHint += localize('toolCompletedHint', "Tool {0} completed.", typeof invocation.confirmationMessages?.title === 'string' ? invocation.confirmationMessages?.title : invocation.confirmationMessages?.title.value);

File: src/vs/workbench/contrib/chat/browser/chatContentParts/chatConfirmationWidget.ts
Before:
		title: string,
		title: string,
		title: string,
After:
		title: string | IMarkdownString,
		title: string | IMarkdownString,
		title: string | IMarkdownString,

File: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatTerminalToolSubPart.ts
Before:
				ariaLabel: title
After:
				ariaLabel: typeof title === 'string' ? title : title.value

File: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatToolConfirmationSubPart.ts
Before:
					ariaLabel: title
						ariaLabel: toolInvocation.confirmationMessages.title
After:
					ariaLabel: typeof title === 'string' ? title : title.value
						ariaLabel: typeof toolInvocation.confirmationMessages.title === 'string' ? toolInvocation.confirmationMessages.title : toolInvocation.confirmationMessages.title.value

File: src/vs/workbench/contrib/chat/browser/languageModelToolsService.ts
Before:
					const result = await this._dialogService.conf...[truncated]
--- Similar PR #249469 ---
File: src/vs/workbench/contrib/chat/browser/chatWidget.ts
Before:
import { pick } from '../../../../base/common/arrays.js';
import { isLocation, Location } from '../../../../editor/common/languages.js';
		if (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(toUri(variable), promptPath.uri))) {
			.filter(pick('isRoot'));
		const promptUris = promptFileVariables.map(toUri);
		assert(
			this.inputPart.currentMode === ChatMode.Agent,
			`Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`,
		);
			.map(pick('id'));
			.filter(hasAddressableValue)
			.map(toUri);
/**
 * Type for any "addressable" object - i.e., an object that has
 * the `value` property that is either a {@link URI} or a {@link Location}.
 */
export type TAddressable<T extends object> = T & { value: URI | Location };

/**
 * Check if provided object is "addressable" - i.e., has the `value`
 * property that is either a {@link URI} or a {@link Location}.
 */
const hasAddressableValue = <T extends object>(
	thing: T,
): thing is TAddressable<T> => {
	if ((!thing) || (('value' in thing) === false)) {
		return false;
	}

	if (URI.isUri(thing.value) || isLocation(thing.value)) {
		return true;
	}

	return false;
};

/**
 * Returns URI of a provided "addressable" object.
 */
const toUri = <T extends object>(
	thing: TAddressable<T>,
): URI => {
	const { value } = thing;

	return URI.isUri(value)
		? value
		: value.uri;
};
After:
		if (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(IChatRequestVariableEntry.toUri(variable), promptPath.uri))) {
			.filter(e => e.isRoot);
		const promptUris = promptFileVariables.map(IChatRequestVariableEntry.toUri).filter(isDefined);
			// NOTE this is a prompt and therefore not localized
		assert(this.inputPart.currentMode === ChatMode.Agent, `Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`);

			.map(tool => tool.id);

			.map(...[truncated]