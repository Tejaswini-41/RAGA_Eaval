{
  "timestamp": "20250528_103500",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly specialized code review expert. Your task is to provide a comprehensive and meticulously detailed review of the submitted code changes.  Your feedback must be exceptionally accurate, actionable, and grounded in the specific code context.  For each identified issue, you must:\n\n1. **Precisely Locate Issues:**  Reference the exact file name, function name, and line numbers where problems are detected.  Avoid vague descriptions; pinpoint the problem location with surgical precision.\n\n2. **Technical Accuracy and Completeness:**  Analyze each changed file and its dependencies.  Thoroughly assess the technical accuracy of the changes, explaining the impact of each modification on the system's functionality, performance, and security.  Address all changed code, including any potential side effects or cascading impacts.  If test coverage is lacking, explicitly state the necessary tests and their intended purpose.\n\n3. **Actionable and Grounded Suggestions:**  Provide concrete, practical, and implementation-ready suggestions for improvement.  Each suggestion must be directly linked to a specific code snippet (using file, function, and line number references) and clearly explain how the suggested change addresses the identified problem.  Avoid speculation; your suggestions must be firmly grounded in the provided codebase.\n\n4. **Contextual Awareness and Faithfulness:**  Demonstrate a deep understanding of the code's context, purpose, and design.  Your review must accurately reflect the code's behavior and intentions. Base all feedback solely on the provided code and avoid making assumptions not explicitly supported by the code itself.  Maintain consistency in your analysis and ensure all feedback aligns with the overall code structure and design principles.\n\n5. **Structure and Organization:**  Structure your review clearly and logically.  Use headings, bullet points, and numbered lists to organize your feedback effectively. Prioritize critical issues and provide a concise summary of your overall assessment.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.6173238158226013,
      "Accuracy": 0.8,
      "Groundedness": 0.3811671087533156,
      "Completeness": 0.6,
      "Faithfulness": 0.3811671087533156,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4611979166666667,
      "BLEU": 0.06567274736060397,
      "ROUGE": 0.16043956043956045,
      "Overall": 0.5301834878051916
    },
    "llama": {
      "Relevance": 0.7066519260406494,
      "Accuracy": 0.8,
      "Groundedness": 0.41538461538461535,
      "Completeness": 0.4,
      "Faithfulness": 0.41538461538461535,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.47886435331230287,
      "BLEU": 0.14097448493069856,
      "ROUGE": 0.29885057471264365,
      "Overall": 0.5382282142640655
    },
    "alibaba": {
      "Relevance": 0.6810854077339172,
      "Accuracy": 0.8,
      "Groundedness": 0.3752043596730245,
      "Completeness": 0.2,
      "Faithfulness": 0.3752043596730245,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.45481283422459895,
      "BLEU": 0.04368583925857938,
      "ROUGE": 0.1649717514124294,
      "Overall": 0.47991275814862866
    }
  },
  "best_model": "llama",
  "baseline_review": "### Summary\n\nThe current PR involves refactoring the chat attachment functionality in the VS Workbench. The key changes include:\n\n* Replacing `attachPrompts` with `attachPrompt` to handle attaching a single prompt to a chat input.\n* Introducing `detachPrompt` to detach a prompt from a chat input.\n* Updating `chatAttachmentModel` to track whether an attachment already exists.\n\nThe purpose of these changes is to improve the handling of chat attachments, allowing for more precise control over attaching and detaching prompts.\n\n### File Changes\n\nThe following files require updates:\n\n1. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts` (lines 10-12)\n\t* Replaced `attachPrompts` with `attachPrompt`.\n2. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts` (lines 15-30)\n\t* Replaced `runAttachPromptAction` with `attachPrompt` and introduced `detachPrompt`.\n3. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts` (lines 10-12)\n\t* Replaced `attachPrompts` with `attachPrompt`.\n4. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts` (lines 10-20)\n\t* Renamed `attachPrompts` to `attachPrompt` and updated its return type.\n5. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts` (lines 10-20)\n\t* Introduced `detachPrompt` function.\n6. `src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts` (lines 10-12)\n\t* Updated `add` method to return a boolean indicating whether the attachment already exists.\n\n### Conflicts\n\nThe following files have a high change frequency:\n\n1. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts`\n\t* This file has been updated in multiple PRs (e.g., #249878, #249895).\n2. `src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts`\n\t* This file has been updated in multiple",
  "session_id": "session_1748408626_e2dd5ca0",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249878,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatToolActions.ts\nBefore:\n\t\t\twidget.input.selectedToolsModel.update(disableToolSets, disableTools);\n\n\nAfter:\n\t\t\twidget.input.selectedToolsModel.disable(disableToolSets, disableTools, false);\n\nFile: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\tonUpdate?.(result);\nAfter:\n\t\t\tif (onUpdate) {\n\t\t\t\tlet didChange = toolsEntries.size !== result.size;\n\t\t\t\tfor (const [key, value] of toolsEntries) {\n\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdidChange = result.get(key) !== value;\n\t\t\t\t}\n\n\t\t\t\tif (didChange) {\n\t\t\t\t\tonUpdate(result);\n\t\t\t\t}\n\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/chatInputPart.ts\nAfter:\n\t\tthis.selectedToolsModel.resetSessionEnablementState();\n\n\nFile: src/vs/workbench/contrib/chat/browser/chatSelectedTools.ts\nBefore:\nimport { autorun, IObservable, observableFromEvent, ObservableMap, transaction } from '../../../../base/common/observable.js';\n\tdisabledToolSets?: readonly string[];\n\tdisabledTools?: readonly string[];\n\t\t@ILanguageModelToolsService toolsService: ILanguageModelToolsService,\n\t\tthis._allTools = observableFromEvent(toolsService.onDidChangeTools, () => Array.from(toolsService.getTools()));\n\t\tconst disabledDataObs = this._selectedTools.map(data => {\n\t\t\treturn (data.disabledToolSets?.length || data.disabledTools?.length)\n\t\t\t\t? {\n\t\t\t\t\ttoolSetIds: new Set(data.disabledToolSets),\n\t\t\t\t\ttoolIds: new Set(data.disabledTools),\n\t\t\t\t: undefined;\n\t\t\tconst toolSets = toolsService.toolSets.read(r);\n\t\t\t\t\t// only homogenous tool sets can shallow tools\n\tselectOnly(toolIds: readonly string[]): void {\n\t\tconst uniqueTools = new Set(toolIds);\n\t\tconst disabledTools = this._allTools.get().filter(tool => !uniqueTools.has(tool.id));\n\t\tthis.update([], disabledTools);\n\tupdate(disabledToolSets: readonly ToolSet[], disableTools: readonly IToolData[]): void {\n\t\tthis._selectedTools.set({\nAfter:\nimport { autorun, derived, IObservable, observableFromEvent, ObservableMap, observableValue, transacti...[truncated]"
    },
    {
      "pr_number": 249895,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatContext.ts\nBefore:\n\nAfter:\n\t\t\tif (res === 0) {\n\t\t\t\tres = a.toolInfo.label.localeCompare(b.toolInfo.label);\n\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\t\tlabel: toolSetOrTool.source.label,\nAfter:\n\t\t\t\tlabel: localize('ext', 'Extension: {0}', toolSetOrTool.source.label),\n\nFile: src/vs/workbench/contrib/chat/common/languageModelToolsService.ts\nBefore:\n\t\t\treturn { ordinal: 3, label: 'Built-In' };\n\t\t\treturn { ordinal: 1, label: 'MCP Servers' };\n\t\t\treturn { ordinal: 0, label: 'User Defined' };\n\t\t\treturn { ordinal: 2, label: 'Extensions' };\nAfter:\nimport { localize } from '../../../../nls.js';\n\t\t\treturn { ordinal: 1, label: localize('builtin', 'Built-In') };\n\t\t\treturn { ordinal: 2, label: localize('mcp', 'MCP Server: {0}', source.label) };\n\t\t\treturn { ordinal: 0, label: localize('user', 'User Defined') };\n\t\t\treturn { ordinal: 3, label: localize('ext', 'Extension: {0}', source.label) };\n\n"
    },
    {
      "pr_number": 249894,
      "changes": "File: src/vs/workbench/contrib/chat/browser/chatAttachmentWidgets.ts\nBefore:\nimport { IChatRequestPasteVariableEntry, IChatRequestVariableEntry, IElementVariableEntry, INotebookOutputVariableEntry, ISCMHistoryItemVariableEntry, OmittedState } from '../common/chatModel.js';\nAfter:\nimport { IChatRequestPasteVariableEntry, IChatRequestToolEntry, IChatRequestToolSetEntry, IChatRequestVariableEntry, IElementVariableEntry, INotebookOutputVariableEntry, ISCMHistoryItemVariableEntry, OmittedState } from '../common/chatModel.js';\nimport { ILanguageModelToolsService, ToolSet } from '../common/languageModelToolsService.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nexport class ToolSetOrToolItemAttachmentWidget extends AbstractChatAttachmentWidget {\n\tconstructor(\n\t\tattachment: IChatRequestToolSetEntry | IChatRequestToolEntry,\n\t\tcurrentLanguageModel: ILanguageModelChatMetadataAndIdentifier | undefined,\n\t\toptions: { shouldFocusClearButton: boolean; supportsDeletion: boolean },\n\t\tcontainer: HTMLElement,\n\t\tcontextResourceLabels: ResourceLabels,\n\t\thoverDelegate: IHoverDelegate,\n\t\t@ILanguageModelToolsService toolsService: ILanguageModelToolsService,\n\t\t@ICommandService commandService: ICommandService,\n\t\t@IOpenerService openerService: IOpenerService,\n\t\t@IHoverService hoverService: IHoverService\n\t) {\n\t\tsuper(attachment, options, container, contextResourceLabels, hoverDelegate, currentLanguageModel, commandService, openerService);\n\n\n\t\tconst toolOrToolSet = Iterable.find(toolsService.getTools(), tool => tool.id === attachment.id) ?? Iterable.find(toolsService.toolSets.get(), toolSet => toolSet.id === attachment.id);\n\n\t\tlet name = attachment.name;\n\t\tconst icon = attachment.icon ?? Codicon.tools;\n\n\t\tif (toolOrToolSet) {\n\t\t\tname = toolOrToolSet.toolReferenceName ?? name;\n\t\t}\n\n\t\tthis.label.setLabel(`$(${icon.id})\\u00A0${name}`, undefined);\n\n\t\tthis.element.style.cursor = 'pointer';\n\t\tthis.element.ariaLabel = localize('chat.attachment', \"Attached context, {0}\", name);\n\n\t\t...[truncated]"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}