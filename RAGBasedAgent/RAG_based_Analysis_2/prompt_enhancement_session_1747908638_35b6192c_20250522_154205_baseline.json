{
  "timestamp": "20250522_154205",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly meticulous and technically proficient code reviewer. Your task is to provide a comprehensive and actionable review of the submitted code changes.  Prioritize accuracy and completeness above all else. Your feedback must be grounded in the specific code context, referencing files, functions, and line numbers precisely.  Avoid generalizations; all suggestions must be directly linked to demonstrable code sections.\n\n**Technical Accuracy & Completeness:** Analyze every changed file and its dependencies.  For each change, precisely specify the file name, function name, and line numbers involved.  Explain the technical implications of each modification, including potential side effects and edge cases.  Quantify the impact whenever possible (e.g., performance improvements, memory usage reduction). Thoroughly assess test coverage; clearly identify any gaps and suggest specific tests needed to ensure comprehensive coverage of the changes.  If relevant, comment on maintainability, readability, and adherence to coding style guidelines.\n\n**Contextual Understanding & Practicality:**  Demonstrate a deep understanding of the surrounding codebase and the intent behind the changes.  Explain how the modifications fit within the larger system architecture and functionality. Your suggestions should be practical, actionable, and readily implementable by developers.  Avoid vague or theoretical suggestions; prioritize concrete and specific recommendations. Ensure your review demonstrates a clear understanding of the code's purpose and context.  Provide clear, concise explanations that avoid jargon and are easily understood by developers with a variety of experience levels.\n\n**Structure and Organization:** Organize your review using a consistent and clear structure. Begin with a summary of the overall impact of the changes.  Then, proceed with a detailed, line-by-line review of each affected file, adhering to the formatting specified for file, function, and line number references.  Conclude with a prioritized list of recommended actions.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.7224613428115845,
      "Accuracy": 0.9,
      "Groundedness": 0.3808022922636103,
      "Completeness": 0.6,
      "Faithfulness": 0.3808022922636103,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.45801104972375695,
      "BLEU": 0.06576143803012309,
      "ROUGE": 0.18834080717488785,
      "Overall": 0.572059496733853
    },
    "llama": {
      "Relevance": 0.694125235080719,
      "Accuracy": 0.8,
      "Groundedness": 0.40926517571884985,
      "Completeness": 0.6,
      "Faithfulness": 0.40926517571884985,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4770440251572327,
      "BLEU": 0.1425876976452075,
      "ROUGE": 0.251441753171857,
      "Overall": 0.5619361584743519
    },
    "alibaba": {
      "Relevance": 0.7292653918266296,
      "Accuracy": 0.8,
      "Groundedness": 0.37058823529411766,
      "Completeness": 0.4,
      "Faithfulness": 0.37058823529411766,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4508905852417303,
      "BLEU": 0.13545994273378142,
      "ROUGE": 0.16755037115588547,
      "Overall": 0.5227548289048923
    }
  },
  "best_model": "deepseek",
  "baseline_review": "\n<think>\nOkay, I need to analyze this PR and provide feedback based on the user's requirements. Let me start by going through each changed file and understanding what's been modified.\n\nFirst, looking at the files, the main changes are in the chat-related components. The biggest change seems to be replacing the older `attachPrompts` function with `attachPrompt`, which now returns an `IAttachResult` object with `wasAlreadyAttached` info. There's also a new `detachPrompt` function introduced. I notice that in `chatRunPromptAction.ts`, there's a condition checking `wasAlreadyAttached` to decide whether to detach after submission. \n\nThe user mentioned similar PRs, but those don't seem directly related, so I'll focus on the current PR's files. \n\n**1. Summary of Key Changes:**\n- The `attachPrompts` function is replaced by `attachPrompt`, which now takes a single file/URI instead of an array. This suggests moving from batch attachment to individual.\n- The return type now includes `wasAlreadyAttached`, which helps in deciding when to detach, which is used in `chatRunPromptAction.ts` to avoid unnecessary detachments.\n- `detachPrompt` is a new utility for removing attachments, called conditionally based on the new flag.\n- `chatPromptAttachmentsCollection.ts`'s `add` method now returns a boolean indicating if the URI was already present.\n\n**2. File Changes Needed:**\n- The PR's `attachPrompt` now expects a URI, but in `askToSelectPrompt.ts`, they pass `selectedOption.value`. Need to verify if `value` is a URI here. Also, in the original `attachPrompts`, maybe the code handled multiple files, but now each is handled individually. But the current code in `askToSelectPrompt.ts` loops through selections, so they might have to loop again if multi-select is allowed now.\n- In `chatPromptAttachmentsCollection.ts`'s `add`, the return is `boolean`, but the old version returned `this`. Methods that relied on the previous return type might have issues, like chain operations. Need to check callers.\n  \n**3. Conflicts:**\n- The `chatPromptAttachmentsCollection`'s `add` method is changed, which is crucial for checking if an item was already there. This is used in `chatAttachPromptAction` and elsewhere. Any existing code that used `add` return value",
  "session_id": "session_1747908638_35b6192c",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249473,
      "changes": "File: src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts\nBefore:\nimport { Button } from '../../../../../base/browser/ui/button/button.js';\nimport { getDefaultHoverDelegate } from '../../../../../base/browser/ui/hover/hoverDelegateFactory.js';\nimport { IHoverService } from '../../../../../platform/hover/browser/hover.js';\n\t\t@IHoverService private readonly hoverService: IHoverService,\n\t\tthis.domNode.classList.toggle('disabled', !this.attachment.enabled);\n\t\tconst range = URI.isUri(this.attachment.value) || !this.attachment.isSelection ? undefined : this.attachment.value!.range;\n\t\tconst ariaLabel = range ? localize('chat.fileAttachmentWithRange', \"Attached {0}, {1}, line {2} to line {3}\", attachmentTypeName, friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment', \"Attached {0}, {1}\", attachmentTypeName, friendlyName);\n\t\tconst hintLabel = localize('hint.label.current', \"Current {0}\", attachmentTypeName);\n\t\tconst hintElement = dom.append(this.domNode, dom.$('span.chat-implicit-hint', undefined, hintLabel));\n\t\tthis._register(this.hoverService.setupManagedHover(getDefaultHoverDelegate('element'), hintElement, title));\n\n\t\tconst buttonMsg = this.attachment.enabled ? localize('disable', \"Disable current {0} context\", attachmentTypeName) : localize('enable', \"Enable current {0} context\", attachmentTypeName);\n\t\tconst toggleButton = this.renderDisposables.add(new Button(this.domNode, { supportIcons: true, title: buttonMsg }));\n\t\ttoggleButton.icon = this.attachment.enabled ? Codicon.eye : Codicon.eyeClosed;\n\t\tthis.renderDisposables.add(toggleButton.onDidClick((e) => {\n\t\t\te.stopPropagation(); // prevent it from triggering the click handler on the parent immediately after rerendering\n\t\t\tthis.attachment.enabled = !this.attachment.enabled;\nAfter:\nimport { ChatAttachmentModel } from '../chatAttachmentModel.js';\n\t\tprivate readonly attachmentModel: ChatAttachmentModel,\n\t\tthis.domNode.classList.add('disabled');\n\t\tconst range ...[truncated]"
    },
    {
      "pr_number": 249497,
      "changes": "File: src/vs/workbench/api/common/extHostLanguageModelTools.ts\nBefore:\n\t\t\t\t\ttitle: result.confirmationMessages.title,\n\t\t\t\t\ttitle: result.confirmationMessages.title,\nAfter:\n\t\t\t\t\ttitle: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),\n\t\t\t\t\ttitle: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),\n\nFile: src/vs/workbench/contrib/chat/browser/chatAccessibilityProvider.ts\nBefore:\n\t\t\t\t\ttoolInvocationHint += localize('toolCompletedHint', \"Tool {0} completed.\", invocation.confirmationMessages?.title);\nAfter:\n\t\t\t\t\ttoolInvocationHint += localize('toolCompletedHint', \"Tool {0} completed.\", typeof invocation.confirmationMessages?.title === 'string' ? invocation.confirmationMessages?.title : invocation.confirmationMessages?.title.value);\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/chatConfirmationWidget.ts\nBefore:\n\t\ttitle: string,\n\t\ttitle: string,\n\t\ttitle: string,\nAfter:\n\t\ttitle: string | IMarkdownString,\n\t\ttitle: string | IMarkdownString,\n\t\ttitle: string | IMarkdownString,\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatTerminalToolSubPart.ts\nBefore:\n\t\t\t\tariaLabel: title\nAfter:\n\t\t\t\tariaLabel: typeof title === 'string' ? title : title.value\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatToolConfirmationSubPart.ts\nBefore:\n\t\t\t\t\tariaLabel: title\n\t\t\t\t\t\tariaLabel: toolInvocation.confirmationMessages.title\nAfter:\n\t\t\t\t\tariaLabel: typeof title === 'string' ? title : title.value\n\t\t\t\t\t\tariaLabel: typeof toolInvocation.confirmationMessages.title === 'string' ? toolInvocation.confirmationMessages.title : toolInvocation.confirmationMessages.title.value\n\nFile: src/vs/workbench/contrib/chat/browser/languageModelToolsService.ts\nBefore:\n\t\t\t\t\tconst result = await this._dialogService.conf...[truncated]"
    },
    {
      "pr_number": 249469,
      "changes": "File: src/vs/workbench/contrib/chat/browser/chatWidget.ts\nBefore:\nimport { pick } from '../../../../base/common/arrays.js';\nimport { isLocation, Location } from '../../../../editor/common/languages.js';\n\t\tif (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(toUri(variable), promptPath.uri))) {\n\t\t\t.filter(pick('isRoot'));\n\t\tconst promptUris = promptFileVariables.map(toUri);\n\t\tassert(\n\t\t\tthis.inputPart.currentMode === ChatMode.Agent,\n\t\t\t`Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`,\n\t\t);\n\t\t\t.map(pick('id'));\n\t\t\t.filter(hasAddressableValue)\n\t\t\t.map(toUri);\n/**\n * Type for any \"addressable\" object - i.e., an object that has\n * the `value` property that is either a {@link URI} or a {@link Location}.\n */\nexport type TAddressable<T extends object> = T & { value: URI | Location };\n\n/**\n * Check if provided object is \"addressable\" - i.e., has the `value`\n * property that is either a {@link URI} or a {@link Location}.\n */\nconst hasAddressableValue = <T extends object>(\n\tthing: T,\n): thing is TAddressable<T> => {\n\tif ((!thing) || (('value' in thing) === false)) {\n\t\treturn false;\n\t}\n\n\tif (URI.isUri(thing.value) || isLocation(thing.value)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Returns URI of a provided \"addressable\" object.\n */\nconst toUri = <T extends object>(\n\tthing: TAddressable<T>,\n): URI => {\n\tconst { value } = thing;\n\n\treturn URI.isUri(value)\n\t\t? value\n\t\t: value.uri;\n};\nAfter:\n\t\tif (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(IChatRequestVariableEntry.toUri(variable), promptPath.uri))) {\n\t\t\t.filter(e => e.isRoot);\n\t\tconst promptUris = promptFileVariables.map(IChatRequestVariableEntry.toUri).filter(isDefined);\n\t\t\t// NOTE this is a prompt and therefore not localized\n\t\tassert(this.inputPart.currentMode === ChatMode.Agent, `Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`);\n\n\t\t\t.map(tool => tool.id);\n\n\t\t\t.map(...[truncated]"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}