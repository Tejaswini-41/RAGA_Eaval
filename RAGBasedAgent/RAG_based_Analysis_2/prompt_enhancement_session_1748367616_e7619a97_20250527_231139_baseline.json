{
  "timestamp": "20250527_231139",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly accurate and meticulous code reviewer.  Your feedback must be grounded in the provided code, referencing specific files, functions, and line numbers consistently.  Each suggestion must be technically accurate, clearly explaining its impact and rationale, and directly linked to the relevant code section.  Avoid vague or generalized feedback.\n\nPrioritize completeness.  Thoroughly analyze all changed files and their dependencies, identifying potential cascading effects and edge cases.  Explicitly address test coverage requirements for each change, specifying the types of tests needed (unit, integration, etc.) and their expected outcomes.\n\nEnsure faithfulness to the code.  Base every suggestion on concrete evidence from the code itself.  Do not make assumptions; any assertion must be demonstrably supported by the code.  If a suggestion relies on external context not provided, clearly state this limitation.\n\nMaintain contextual precision.  Your feedback should demonstrate a deep understanding of the code's purpose, functionality, and its interaction with other system components.  Recall relevant aspects of the codebase and project context (if provided).\n\nStructure your review clearly.  Use a consistent format (e.g., per-file, per-function, or per-line), ensuring easy navigation and comprehension.  Prioritize actionable suggestions, providing concrete implementation steps and avoiding ambiguous language.  Frame your feedback constructively, aiming to enhance code quality and maintainability.  Quantify the impact of your suggestions whenever possible (e.g., \"This change reduces execution time by X%\").  Your response must be concise yet comprehensive, addressing all aspects of the code changes.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.7752314209938049,
      "Accuracy": 0.8,
      "Groundedness": 0.35888594164456233,
      "Completeness": 0.2,
      "Faithfulness": 0.35888594164456233,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4462724935732648,
      "BLEU": 0.06942783829411125,
      "ROUGE": 0.16063348416289594,
      "Overall": 0.4952674126865136
    },
    "llama": {
      "Relevance": 0.5859779119491577,
      "Accuracy": 0.8,
      "Groundedness": 0.44594594594594594,
      "Completeness": 0.6,
      "Faithfulness": 0.44594594594594594,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.5020114942528736,
      "BLEU": 0.09142443536148707,
      "ROUGE": 0.22024471635150167,
      "Overall": 0.5472699533026011
    },
    "alibaba": {
      "Relevance": 0.011935766786336899,
      "Accuracy": 1.0,
      "Groundedness": 0.3023255813953488,
      "Completeness": 0.0,
      "Faithfulness": 0.3023255813953488,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4,
      "BLEU": 0.021300733682208986,
      "ROUGE": 0.0070052539404553416,
      "Overall": 0.3242675690174704
    }
  },
  "best_model": "llama",
  "baseline_review": "## Analysis of the PR\n\n### 1. Summary - Key changes and their purpose\n\nThe PR involves refactoring the chat attachment model to support attaching and detaching single prompts. The key changes include:\n\n* Renaming `attachPrompts` to `attachPrompt` and modifying it to handle a single file instead of an array of files. (File: `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts`)\n* Introducing a new function `detachPrompt` to detach a prompt from a chat input. (File: `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts`)\n* Updating the return type of `add` method in `chatPromptAttachmentsCollection.ts` to indicate whether the attachment already exists. (File: `src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts`)\n\nThe purpose of these changes is to improve the handling of chat attachments by allowing single prompts to be attached and detached.\n\n### 2. File Changes - Specific files needing updates\n\nThe following files need updates:\n\n* `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts`\n* `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts`\n* `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts`\n* `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts`\n* `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts`\n* `src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts`\n\n### 3. Conflicts - Files with high change frequency\n\nBased on the provided similar PRs, the following files have high change frequency:\n\n* `src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts` (PR 249878 and 249895)\n* `src/vs/workbench/contrib/chat/browser/chatSelectedTools.ts` (PR 249878)\n\n### 4. Risks - Potential breaking changes with evidence\n\nThe following changes may introduce potential breaking changes:\n\n* The `add` method in `chatPrompt",
  "session_id": "session_1748367616_e7619a97",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249878,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatToolActions.ts\nBefore:\n\t\t\twidget.input.selectedToolsModel.update(disableToolSets, disableTools);\n\n\nAfter:\n\t\t\twidget.input.selectedToolsModel.disable(disableToolSets, disableTools, false);\n\nFile: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\tonUpdate?.(result);\nAfter:\n\t\t\tif (onUpdate) {\n\t\t\t\tlet didChange = toolsEntries.size !== result.size;\n\t\t\t\tfor (const [key, value] of toolsEntries) {\n\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdidChange = result.get(key) !== value;\n\t\t\t\t}\n\n\t\t\t\tif (didChange) {\n\t\t\t\t\tonUpdate(result);\n\t\t\t\t}\n\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/chatInputPart.ts\nAfter:\n\t\tthis.selectedToolsModel.resetSessionEnablementState();\n\n\nFile: src/vs/workbench/contrib/chat/browser/chatSelectedTools.ts\nBefore:\nimport { autorun, IObservable, observableFromEvent, ObservableMap, transaction } from '../../../../base/common/observable.js';\n\tdisabledToolSets?: readonly string[];\n\tdisabledTools?: readonly string[];\n\t\t@ILanguageModelToolsService toolsService: ILanguageModelToolsService,\n\t\tthis._allTools = observableFromEvent(toolsService.onDidChangeTools, () => Array.from(toolsService.getTools()));\n\t\tconst disabledDataObs = this._selectedTools.map(data => {\n\t\t\treturn (data.disabledToolSets?.length || data.disabledTools?.length)\n\t\t\t\t? {\n\t\t\t\t\ttoolSetIds: new Set(data.disabledToolSets),\n\t\t\t\t\ttoolIds: new Set(data.disabledTools),\n\t\t\t\t: undefined;\n\t\t\tconst toolSets = toolsService.toolSets.read(r);\n\t\t\t\t\t// only homogenous tool sets can shallow tools\n\tselectOnly(toolIds: readonly string[]): void {\n\t\tconst uniqueTools = new Set(toolIds);\n\t\tconst disabledTools = this._allTools.get().filter(tool => !uniqueTools.has(tool.id));\n\t\tthis.update([], disabledTools);\n\tupdate(disabledToolSets: readonly ToolSet[], disableTools: readonly IToolData[]): void {\n\t\tthis._selectedTools.set({\nAfter:\nimport { autorun, derived, IObservable, observableFromEvent, ObservableMap, observableValue, transacti...[truncated]"
    },
    {
      "pr_number": 249895,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatContext.ts\nBefore:\n\nAfter:\n\t\t\tif (res === 0) {\n\t\t\t\tres = a.toolInfo.label.localeCompare(b.toolInfo.label);\n\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\t\tlabel: toolSetOrTool.source.label,\nAfter:\n\t\t\t\tlabel: localize('ext', 'Extension: {0}', toolSetOrTool.source.label),\n\nFile: src/vs/workbench/contrib/chat/common/languageModelToolsService.ts\nBefore:\n\t\t\treturn { ordinal: 3, label: 'Built-In' };\n\t\t\treturn { ordinal: 1, label: 'MCP Servers' };\n\t\t\treturn { ordinal: 0, label: 'User Defined' };\n\t\t\treturn { ordinal: 2, label: 'Extensions' };\nAfter:\nimport { localize } from '../../../../nls.js';\n\t\t\treturn { ordinal: 1, label: localize('builtin', 'Built-In') };\n\t\t\treturn { ordinal: 2, label: localize('mcp', 'MCP Server: {0}', source.label) };\n\t\t\treturn { ordinal: 0, label: localize('user', 'User Defined') };\n\t\t\treturn { ordinal: 3, label: localize('ext', 'Extension: {0}', source.label) };\n\n"
    },
    {
      "pr_number": 249870,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\t\tchildren: []\nAfter:\n\t\t\tconst buttons: ActionableButton[] = [];\n\n\t\t\t\tchildren: [],\n\t\t\t\tbuttons\n\n"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}