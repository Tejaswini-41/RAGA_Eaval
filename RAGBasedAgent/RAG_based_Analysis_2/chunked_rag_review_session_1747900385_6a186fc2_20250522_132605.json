{
  "pr_number": 246149,
  "chunked_review": "# PR Review with Hybrid Chunking\n\n## Chunking Strategy: Hybrid\n\n## Summary\n* Introducing a new type `TAddressable` and a function `hasAddressableValue` to check if an object has a `value` property that is either a `URI` or a `Location`.\n*   Renaming and updating the `detachPrompt` function to accept a `file` parameter of type `URI` and an `options` object of type `IDetachPromptOptions`.\n- The provided PR contains several changes to the codebase, primarily focusing on the `detachPrompt` function and related types. The key changes include:\n- The current PR appears to be refactoring the code to attach and detach prompts in a more modular and manageable way. The key changes include:\n- The provided PR appears to be related to refactoring and adding functionality to the chat widget in a code editor. The key changes include:\n*   Updating the `add` method in `chatPromptAttachmentsCollection.ts` to return a boolean indicating whether the attachment already exists.\n- The purpose of these changes appears to be refactoring and improving the functionality related to chat prompts and attachments.\n* Extracting `attachPrompt` and `detachPrompt` functions from `attachPrompts` to handle individual prompt attachments.\n* Adding a new function `attachPrompt` that returns an object with a `widget` and a boolean `wasAlreadyAttached`.\n*   Introduction of the `IDetachPromptOptions` interface to define options for the `detachPrompt` function.\n* Updating the `askToSelectPrompt` function to use the new `attachPrompt` and `detachPrompt` functions.\n- The current PR involves several changes in the codebase related to chat functionality, specifically:\n* Changes to `ariaLabel` assignments to handle cases where `title` might be an `IMarkdownString`\n* Introduction of new import statements for `attachPrompt`, `detachPrompt`, and `IChatWidget`\n* Updates to type definitions for `title` to use `string | IMarkdownString`\n\n## File Changes\n* After: `import { IChatWidget } from '../../chat.js'; import { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js'; import { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';`\n- 1. **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts**\n*   The `add` method is updated to return a boolean value indicating whether the attachment already exists. (lines 10-14)\n* Before: `import { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';`\n* After: `import { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';`\n- 4. **src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatToolConfirmationSubPart.ts**\n* Impact: Replaced `attachPrompts` with `attachPrompt`, potentially changing the behavior of prompt attachment.\n- 3. **src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatTerminalToolSubPart.ts**\n* After: The file has been updated to use the new `TAddressable` type and `hasAddressableValue` function.\n- 1.  **src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts**\n- 1. **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts**\n* After: The file has been refactored to include the new `attachPrompt` function and related types.\n- 2. **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts**\n* Change: Replaced `attachPrompts` with `attachPrompt` to handle individual prompt attachments.\n* Impact: Introduced new imports and potentially changed the logic for running prompt actions.\n\n## Conflict Predictions\n- No obvious conflicts are apparent, but files with high change frequency that may require additional attention include:\n* This file has been updated to use the new types and functions, but it may still be undergoing changes.\n*   This file seems to have related changes, and its modification might conflict with the current PR.\n- Based on the provided information, the following files might have high change frequency:\n- 2. **src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts**\n* `src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts`\n- 1.  **src/vs/workbench/contrib/chat/browser/chatWidget.ts**\n- 1. **src/vs/workbench/contrib/chat/browser/chatWidget.ts**\n* `src/vs/workbench/contrib/chat/browser/chatWidget.ts`\n- The following files may have high change frequency:\n\n## Breakage Risks\n*   The introduction of a new interface and function might require additional testing and could potentially break existing code if not properly handled.\n* The introduction of new functions (`attachPrompt` and `detachPrompt`) may affect existing code that relies on the original `attachPrompts` function.\n*   The updated `add` method now returns a boolean value. This change might break existing code that relies on the previous behavior. (lines 10-14)\n* The new `TAddressable` type and `hasAddressableValue` function may break existing code if not properly used.\n* Changes to the attachment and detachment process may impact the functionality of chat prompts.\n- This change replaces the original `attachPrompts` function with the new `attachPrompt` function.\n- 2.  **Introduction of `IDetachPromptOptions` interface and `detachPrompt` function**\n* Evidence: The `hasAddressableValue` function is used in `src/vs/workbench/cont\n* @returns `true` if the attachment already exists, `false` otherwise.\n- 1.  **Updated `add` method in `chatPromptAttachmentsCollection.ts`**\n- const attachResult = await attachPrompt(selectedOption.value, ...);\n- The following potential breaking changes have been identified:\n- lastActiveWidget = await attachPrompts(selectedItems, ...);\n- The following potential breaking changes are identified:\n- 1. **Introduction of new types and functions**\n\n## Test Coverage\n- To ensure the changes are properly tested, the following test\n\n",
  "best_model": "llama",
  "model_metrics": {
    "deepseek": {
      "Relevance": 0.7473400831222534,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.4,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.0,
      "AnswerRelevance": 0.27999999999999997,
      "BLEU": 0.0612957497932821,
      "ROUGE": 0.15925925925925927,
      "Overall": 0.462
    },
    "llama": {
      "Relevance": 0.8031545877456665,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.3,
      "Faithfulness": 0.19999999999999996,
      "ContextualPrecision": 1.0,
      "AnswerRelevance": 0.82,
      "BLEU": 0.2011824914010416,
      "ROUGE": 0.2436647173489279,
      "Overall": 0.734
    },
    "alibaba": {
      "Relevance": 0.8030582666397095,
      "Accuracy": 0.8,
      "Groundedness": 0.6,
      "Completeness": 0.2,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.0,
      "AnswerRelevance": 0.26,
      "BLEU": 0.04016138436407654,
      "ROUGE": 0.18012999071494895,
      "Overall": 0.425
    }
  },
  "chunking_stats": {
    "success": true,
    "current_pr_chunks": 5,
    "similar_pr_chunks": 11,
    "total_chunks": 16
  },
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249473,
      "changes": "File: src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts\nBefore:\nimport { Button } from '../../../../../base/browser/ui/button/button.js';\nimport { getDefaultHoverDelegate } from '../../../../../base/browser/ui/hover/hoverDelegateFactory.js';\nimport { IHoverService } from '../../../../../platform/hover/browser/hover.js';\n\t\t@IHoverService private readonly hoverService: IHoverService,\n\t\tthis.domNode.classList.toggle('disabled', !this.attachment.enabled);\n\t\tconst range = URI.isUri(this.attachment.value) || !this.attachment.isSelection ? undefined : this.attachment.value!.range;\n\t\tconst ariaLabel = range ? localize('chat.fileAttachmentWithRange', \"Attached {0}, {1}, line {2} to line {3}\", attachmentTypeName, friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment', \"Attached {0}, {1}\", attachmentTypeName, friendlyName);\n\t\tconst hintLabel = localize('hint.label.current', \"Current {0}\", attachmentTypeName);\n\t\tconst hintElement = dom.append(this.domNode, dom.$('span.chat-implicit-hint', undefined, hintLabel));\n\t\tthis._register(this.hoverService.setupManagedHover(getDefaultHoverDelegate('element'), hintElement, title));\n\n\t\tconst buttonMsg = this.attachment.enabled ? localize('disable', \"Disable current {0} context\", attachmentTypeName) : localize('enable', \"Enable current {0} context\", attachmentTypeName);\n\t\tconst toggleButton = this.renderDisposables.add(new Button(this.domNode, { supportIcons: true, title: buttonMsg }));\n\t\ttoggleButton.icon = this.attachment.enabled ? Codicon.eye : Codicon.eyeClosed;\n\t\tthis.renderDisposables.add(toggleButton.onDidClick((e) => {\n\t\t\te.stopPropagation(); // prevent it from triggering the click handler on the parent immediately after rerendering\n\t\t\tthis.attachment.enabled = !this.attachment.enabled;\nAfter:\nimport { ChatAttachmentModel } from '../chatAttachmentModel.js';\n\t\tprivate readonly attachmentModel: ChatAttachmentModel,\n\t\tthis.domNode.classList.add('disabled');\n\t\tconst range ...[truncated]"
    },
    {
      "pr_number": 249497,
      "changes": "File: src/vs/workbench/api/common/extHostLanguageModelTools.ts\nBefore:\n\t\t\t\t\ttitle: result.confirmationMessages.title,\n\t\t\t\t\ttitle: result.confirmationMessages.title,\nAfter:\n\t\t\t\t\ttitle: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),\n\t\t\t\t\ttitle: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),\n\nFile: src/vs/workbench/contrib/chat/browser/chatAccessibilityProvider.ts\nBefore:\n\t\t\t\t\ttoolInvocationHint += localize('toolCompletedHint', \"Tool {0} completed.\", invocation.confirmationMessages?.title);\nAfter:\n\t\t\t\t\ttoolInvocationHint += localize('toolCompletedHint', \"Tool {0} completed.\", typeof invocation.confirmationMessages?.title === 'string' ? invocation.confirmationMessages?.title : invocation.confirmationMessages?.title.value);\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/chatConfirmationWidget.ts\nBefore:\n\t\ttitle: string,\n\t\ttitle: string,\n\t\ttitle: string,\nAfter:\n\t\ttitle: string | IMarkdownString,\n\t\ttitle: string | IMarkdownString,\n\t\ttitle: string | IMarkdownString,\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatTerminalToolSubPart.ts\nBefore:\n\t\t\t\tariaLabel: title\nAfter:\n\t\t\t\tariaLabel: typeof title === 'string' ? title : title.value\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatToolConfirmationSubPart.ts\nBefore:\n\t\t\t\t\tariaLabel: title\n\t\t\t\t\t\tariaLabel: toolInvocation.confirmationMessages.title\nAfter:\n\t\t\t\t\tariaLabel: typeof title === 'string' ? title : title.value\n\t\t\t\t\t\tariaLabel: typeof toolInvocation.confirmationMessages.title === 'string' ? toolInvocation.confirmationMessages.title : toolInvocation.confirmationMessages.title.value\n\nFile: src/vs/workbench/contrib/chat/browser/languageModelToolsService.ts\nBefore:\n\t\t\t\t\tconst result = await this._dialogService.conf...[truncated]"
    },
    {
      "pr_number": 249469,
      "changes": "File: src/vs/workbench/contrib/chat/browser/chatWidget.ts\nBefore:\nimport { pick } from '../../../../base/common/arrays.js';\nimport { isLocation, Location } from '../../../../editor/common/languages.js';\n\t\tif (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(toUri(variable), promptPath.uri))) {\n\t\t\t.filter(pick('isRoot'));\n\t\tconst promptUris = promptFileVariables.map(toUri);\n\t\tassert(\n\t\t\tthis.inputPart.currentMode === ChatMode.Agent,\n\t\t\t`Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`,\n\t\t);\n\t\t\t.map(pick('id'));\n\t\t\t.filter(hasAddressableValue)\n\t\t\t.map(toUri);\n/**\n * Type for any \"addressable\" object - i.e., an object that has\n * the `value` property that is either a {@link URI} or a {@link Location}.\n */\nexport type TAddressable<T extends object> = T & { value: URI | Location };\n\n/**\n * Check if provided object is \"addressable\" - i.e., has the `value`\n * property that is either a {@link URI} or a {@link Location}.\n */\nconst hasAddressableValue = <T extends object>(\n\tthing: T,\n): thing is TAddressable<T> => {\n\tif ((!thing) || (('value' in thing) === false)) {\n\t\treturn false;\n\t}\n\n\tif (URI.isUri(thing.value) || isLocation(thing.value)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Returns URI of a provided \"addressable\" object.\n */\nconst toUri = <T extends object>(\n\tthing: TAddressable<T>,\n): URI => {\n\tconst { value } = thing;\n\n\treturn URI.isUri(value)\n\t\t? value\n\t\t: value.uri;\n};\nAfter:\n\t\tif (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(IChatRequestVariableEntry.toUri(variable), promptPath.uri))) {\n\t\t\t.filter(e => e.isRoot);\n\t\tconst promptUris = promptFileVariables.map(IChatRequestVariableEntry.toUri).filter(isDefined);\n\t\t\t// NOTE this is a prompt and therefore not localized\n\t\tassert(this.inputPart.currentMode === ChatMode.Agent, `Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`);\n\n\t\t\t.map(tool => tool.id);\n\n\t\t\t.map(...[truncated]"
    }
  ]
}