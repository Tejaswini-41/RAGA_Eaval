{
  "timestamp": "20250419_192227",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly meticulous and technically proficient code reviewer.  Your task is to provide a comprehensive and actionable review of the provided code changes, focusing on technical accuracy, completeness, and faithfulness.  Your feedback must be precisely grounded in the code itself, referencing specific files, functions, and line numbers for every suggestion.  Avoid generalizations; each comment must be demonstrably linked to a particular code section.\n\n**Technical Accuracy & Completeness:**  Your review must cover all modified files and their direct and indirect dependencies.  Analyze the impact of each change on functionality, performance, security, and maintainability. For each identified issue, clearly explain its potential consequences and provide concrete, implementation-ready solutions.  Quantify the impact whenever possible (e.g., \"This change increases the time complexity from O(n) to O(n^2)\").  Address potential edge cases and error handling.  Specify required additions or modifications to existing unit and integration tests to ensure thorough test coverage of the changes.\n\n**Faithfulness & Contextual Precision:**  Base all your suggestions solely on the provided code and accompanying context (if any).  Do not introduce assumptions or hypothetical scenarios.  Clearly articulate the rationale behind each recommendation, explicitly demonstrating how it addresses a specific aspect of the code or its broader context.  Maintain a consistent and logical flow of ideas, ensuring that your feedback is well-structured and easy to understand.\n\n**Structure and Deliverables:** Organize your review into distinct sections, each focusing on a specific file or a group of related changes.  For each section, provide a concise summary of the overall impact of the changes before diving into detailed, line-by-line feedback.  Conclude with a prioritized list of action items, including severity levels (e.g., critical, major, minor) and estimated effort for implementation.  Prioritize clarity and conciseness.  Use a consistent and professional tone.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.6021772027015686,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.3,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.0,
      "AnswerRelevance": 0.94,
      "BLEU": 0.04065425428798724,
      "ROUGE": 0.16293929712460065,
      "Overall": 0.512
    },
    "llama": {
      "Relevance": 0.7276573777198792,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.4,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.7,
      "AnswerRelevance": 1.0,
      "BLEU": 0.1543909476981724,
      "ROUGE": 0.24766751484308736,
      "Overall": 0.654
    },
    "alibaba": {
      "Relevance": 0.5724858641624451,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.3,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.0,
      "AnswerRelevance": 0.39999999999999997,
      "BLEU": 0.06567274736060395,
      "ROUGE": 0.19563459983831852,
      "Overall": 0.482
    }
  },
  "best_model": "llama",
  "baseline_review": "### Summary\n\nThe current PR involves refactoring the chat prompt attachment functionality. Key changes include:\n\n* Replacing `attachPrompts` with `attachPrompt` to handle single file attachments\n* Introducing `detachPrompt` to remove attachments from chat input\n* Updating related functions and interfaces to support the new attachment logic\n\nThe purpose of these changes is to improve the handling of chat prompt attachments, making it more efficient and scalable.\n\n### File Changes\n\nThe following files require updates:\n\n1. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts`\n\t* Replaced `attachPrompts` with `attachPrompt` (lines 10-12)\n\t* Updated function signature and variable names\n2. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts`\n\t* Imported `attachPrompt` and `detachPrompt` (lines 10-12)\n\t* Updated function logic to handle attachment and detachment\n3. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts`\n\t* Replaced `attachPrompts` with `attachPrompt` (lines 15-17)\n\t* Updated variable names and function calls\n4. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts`\n\t* Renamed `attachPrompts` to `attachPrompt` (lines 10-20)\n\t* Introduced `IAttachResult` interface and updated function return type\n5. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts`\n\t* Added new file with `detachPrompt` function (lines 10-20)\n6. `src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts`\n\t* Updated `add` method to return a boolean value (lines 10-12)\n\n### Conflicts\n\nFiles with high change frequency:\n\n1. `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts`\n\t* Recent changes: 246914, 246891\n2. `src/vs/workbench/contrib/chat/browser/attachments/promptInstructions/promptInstructionsCollectionWidget.ts`\n\t* Recent changes: 246931, 246",
  "session_id": "session_1745070679_e95b3c5b",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 246891,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatActions.ts\nBefore:\n\t\t\t\tmessage = localize('chatQuotaExceeded', \"You've reached your monthly chat messages quota. You still have free code completions available.\");\n\t\t\t\tmessage = localize('completionsQuotaExceeded', \"You've reached your monthly code completions quota. You still have free chat messages available.\");\n\t\t\t\tmessage = localize('chatAndCompletionsQuotaExceeded', \"You've reached your monthly chat messages and code completions quota.\");\n\t\t\tconst upgradeToPro = limited ? localize('upgradeToPro', \"Upgrade to Copilot Pro (your first 30 days are free) for:\\n- Unlimited code completions\\n- Unlimited basic chat messages\\n- Access to premium models\") : undefined;\n\t\t\t\t\tprimaryActionTitle = localize('chatQuotaExceededButton', \"Copilot Free plan chat messages quota reached. Click for details.\");\nAfter:\n\t\t\t\tmessage = localize('chatQuotaExceeded', \"You've reached your monthly chat requests quota. You still have free code completions available.\");\n\t\t\t\tmessage = localize('completionsQuotaExceeded', \"You've reached your monthly code completions quota. You still have free chat requests available.\");\n\t\t\t\tmessage = localize('chatAndCompletionsQuotaExceeded', \"You've reached your monthly chat requests and code completions quota.\");\n\t\t\tconst upgradeToPro = limited ? localize('upgradeToPro', \"Upgrade to Copilot Pro (your first 30 days are free) for:\\n- Unlimited code completions\\n- Unlimited basic chat requests\\n- Access to premium models\") : undefined;\n\t\t\t\t\tprimaryActionTitle = localize('chatQuotaExceededButton', \"Copilot Free plan chat requests quota reached. Click for details.\");\n\nFile: src/vs/workbench/contrib/chat/browser/chatStatus.ts\nBefore:\n\t\t\tconst completionsQuotaIndicator = completionsQuota ? this.createQuotaIndicator(this.element, completionsQuota, localize('completionsLabel', \"Code completions\")) : undefined;\n\t\t\tconst chatQuotaIndicator = chatQuota ? this.createQuotaIndicator(this.element, chatQuota, localize('c...[truncated]"
    },
    {
      "pr_number": 246931,
      "changes": "File: src/vs/editor/common/codecs/markdownCodec/parsers/markdownLink.ts\nBefore:\n * into the {@linkcode MarkdownLinkCaption} parser type which continues the general\n * Otherwise, if one of the stop characters defined in the {@linkcode MARKDOWN_LINK_STOP_CHARACTERS}\n * The parser responsible for transitioning from a {@linkcode PartialMarkdownLinkCaption}\n * transitions into the {@linkcode MarkdownLink} token type which signifies the end of the entire\n * Otherwise, if one of the stop characters defined in the {@linkcode MARKDOWN_LINK_STOP_CHARACTERS}\n\t * See comment in the {@linkcode accept} method for more details.\nAfter:\n * into the {@link MarkdownLinkCaption} parser type which continues the general\n * Otherwise, if one of the stop characters defined in the {@link MARKDOWN_LINK_STOP_CHARACTERS}\n * The parser responsible for transitioning from a {@link PartialMarkdownLinkCaption}\n * transitions into the {@link MarkdownLink} token type which signifies the end of the entire\n * Otherwise, if one of the stop characters defined in the {@link MARKDOWN_LINK_STOP_CHARACTERS}\n\t * See comment in the {@link accept} method for more details.\n\nFile: src/vs/workbench/contrib/chat/browser/attachments/promptInstructions/promptInstructionsCollectionWidget.ts\nBefore:\n * See {@linkcode InstructionsAttachmentWidget}.\n\t * See {@linkcode onAttachmentsCountChange}.\n\tprivate _onAttachmentsCountChange = this._register(new Emitter<void>());\n\t * Subscribe to the `onAttachmentsCountChange` event.\n\tpublic onAttachmentsCountChange(callback: () => unknown): this {\n\t\tthis._register(this._onAttachmentsCountChange.event(callback));\n\t\t\tthis._onAttachmentsCountChange.fire();\n\t\tthis._onAttachmentsCountChange.fire();\nAfter:\n * See {@link InstructionsAttachmentWidget}.\n\t * See {@link onAttachmentsChange}.\n\tprivate _onAttachmentsChange = this._register(new Emitter<void>());\n\t * Subscribe to the `onAttachmentsChange` event.\n\tpublic onAttachmentsChange(callback: () => unknown): this {\n\t\tthis._register(this._on...[truncated]"
    },
    {
      "pr_number": 246914,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatContextActions.ts\nBefore:\nimport { runAttachInstructionsAction } from './promptActions/index.js';\n\n\nAfter:\nimport { runAttachInstructionsAction, registerPromptActions } from './promptActions/index.js';\n\n/**\n * Register all actions related to reusable prompt files.\n */\nregisterPromptActions();\n\nFile: src/vs/workbench/contrib/chat/browser/actions/promptActions/dialogs/askToSelectPrompt/utils/runPrompt.ts\nBefore:\n\tawait widget.setInput(`/${basename(file)}`);\n\nAfter:\n\twidget.setInput(`/${basename(file)}`);\n\n\nFile: src/vs/workbench/contrib/chat/browser/actions/promptActions/index.ts\nBefore:\n\nexport { runAttachInstructionsAction } from './chatAttachInstructionsAction.js';\nAfter:\nexport { runAttachInstructionsAction } from './chatAttachInstructionsAction.js';\n\nFile: src/vs/workbench/contrib/chat/browser/attachments/promptInstructions/promptInstructionsCollectionWidget.ts\nAfter:\n\t/**\n\t * Get a promise that resolves when parsing/resolving processes\n\t * are fully completed, including all possible nested child references.\n\t */\n\tpublic allSettled() {\n\t\treturn this.model.allSettled();\n\t}\n\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentModel.ts\nBefore:\n\t\tconst { errorCondition } = this.reference;\n\t\tthis._onUpdate.fire = this._onUpdate.fire.bind(this._onUpdate);\n\t\tthis._reference.onUpdate(this._onUpdate.fire);\nAfter:\n\t\tconst { errorCondition } = reference;\n\t/**\n\t * Get list of all tools associated with the prompt.\n\t *\n\t * Note! This property returns pont-in-time state of the tools metadata\n\t *       and does not take into account if the prompt or its nested child\n\t *       references are still being resolved. Please use the {@link settled}\n\t *       or {@link allSettled} properties if you need to retrieve the final\n\t *       list of the tools available.\n\t */\n\tpublic get toolsMetadata(): readonly string[] | null {\n\t\treturn this.reference.allToolsMetadata;\n\t}\n\n\t\tthis._reference.onUpdate(\n\t\t...[truncated]"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}