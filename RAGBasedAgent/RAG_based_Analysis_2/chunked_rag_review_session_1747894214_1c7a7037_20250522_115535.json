{
  "pr_number": 246149,
  "chunked_review": "# PR Review with Hybrid Semantic Chunking\n\n## Summary\n- The current PR involves refactoring the `attachPrompts` function into a new function called `attachPrompt`. The purpose of this change appears to be to modify the functionality to handle a single prompt instead of multiple prompts.\n- The PR involves refactoring the code to attach and detach prompts in a more granular way. The main changes include:\n- Replacing `attachPrompts` with `attachPrompt` to handle individual prompts.\n- Adding immediate submission and detachment of prompts.\n\n## File Changes\n- 2. **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.js** and **detachPrompt.js**\n- 2. **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts**\n- 1. **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts**\n- Replaced `attachPrompts` with `attachPrompt` to handle individual prompts. (Lines 10-15)\n- The function call is updated to handle the result of `attachPrompt` differently.\n- The function now returns an object `IAttachResult` which includes the widget.\n- The import statement is changed from `attachPrompts` to `attachPrompt`.\n- New utility functions for attaching and detaching individual prompts.\n- lastActiveWidget = await attachPrompts(selectedItems, /* ... */);\n- const attachResult = await attachPrompt(selectedOption.value);\n- The function `attachPrompts` is renamed to `attachPrompt`.\n- widget.attachmentModel.promptInstructions.add(file.value);\n- import { attachPrompts } from './utils/attachPrompts.js';\n- import { attachPrompt } from './utils/attachPrompt.js';\n- The function now handles a single prompt.\n\n## Conflict Predictions\n- Based on the provided information, there are no direct conflicts mentioned. However, files with high change frequency that might need attention include:\n- **src/vs/workbench/contrib/chat/browser/actions/chatExecuteActions.js**: May interact with prompt attachment and detachment logic.\n- **src/vs/workbench/contrib/chat/browser/chat.js**: Defines `IChatWidget` and might be impacted by changes to prompt handling.\n- **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts**\n- **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts**\n- No direct conflicts are evident, but files with high change frequency that might interact with these changes include:\n\n## Breakage Risks\n- The immediate submission and detachment of prompts could lead to unexpected behavior if not properly tested. (Evidence: `await widget.acceptInput();` and `if (wasAlreadyAttached === false) { await detachPrompt(resource, { widget }); }` in **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts**)\n- Changes to utility functions `attachPrompt` and `detachPrompt` might affect other parts of the codebase. (Evidence: Usage in **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts**)\n- Potential breaking changes:\n- Potential breaking\n\n## Test Coverage\n- **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.test.ts**: Should verify the correct attachment, submission, and detachment of prompts.\n- **src/vs/workbench/contrib/chat/browser/chat.test.ts**: General chat functionality tests that might be impacted by prompt handling changes.\n- Required test coverage:\n\n## Code Quality\n- **Granularity**: The new `attachPrompt` and `detachPrompt\n- Code smells and suggestions:\n\n",
  "best_model": "llama",
  "model_metrics": {
    "deepseek": {
      "Relevance": 0.7976353168487549,
      "Accuracy": 0.95,
      "Groundedness": 0.7,
      "Completeness": 0.5,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.5,
      "AnswerRelevance": 0.6499999999999999,
      "BLEU": 0.07439820585622745,
      "ROUGE": 0.1723779854620976,
      "Overall": 0.671
    },
    "llama": {
      "Relevance": 0.8289958834648132,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.6,
      "Faithfulness": 0.33333333333333337,
      "ContextualPrecision": 0.9,
      "AnswerRelevance": 0.8799999999999999,
      "BLEU": 0.1425876976452075,
      "ROUGE": 0.22633297062023938,
      "Overall": 0.776
    },
    "alibaba": {
      "Relevance": 0.7684295177459717,
      "Accuracy": 0.8,
      "Groundedness": 0.7,
      "Completeness": 0.2,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.0,
      "AnswerRelevance": 0.5499999999999999,
      "BLEU": 0.0402724819242185,
      "ROUGE": 0.16969696969696968,
      "Overall": 0.475
    }
  },
  "chunking_stats": {
    "success": true,
    "current_pr_chunks": 5,
    "similar_pr_chunks": 34,
    "total_chunks": 39
  },
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249512,
      "changes": "File: src/vs/workbench/contrib/chat/electron-sandbox/actions/voiceChatActions.ts\nBefore:\n\t\t\t\tdetail: error && !isCancellationError(error) ? toErrorMessage(error) : undefined,\nAfter:\n\t\t\tif (isCancellationError(error)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t\tdetail: toErrorMessage(error),\n\n"
    },
    {
      "pr_number": 249473,
      "changes": "File: src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts\nBefore:\nimport { Button } from '../../../../../base/browser/ui/button/button.js';\nimport { getDefaultHoverDelegate } from '../../../../../base/browser/ui/hover/hoverDelegateFactory.js';\nimport { IHoverService } from '../../../../../platform/hover/browser/hover.js';\n\t\t@IHoverService private readonly hoverService: IHoverService,\n\t\tthis.domNode.classList.toggle('disabled', !this.attachment.enabled);\n\t\tconst range = URI.isUri(this.attachment.value) || !this.attachment.isSelection ? undefined : this.attachment.value!.range;\n\t\tconst ariaLabel = range ? localize('chat.fileAttachmentWithRange', \"Attached {0}, {1}, line {2} to line {3}\", attachmentTypeName, friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment', \"Attached {0}, {1}\", attachmentTypeName, friendlyName);\n\t\tconst hintLabel = localize('hint.label.current', \"Current {0}\", attachmentTypeName);\n\t\tconst hintElement = dom.append(this.domNode, dom.$('span.chat-implicit-hint', undefined, hintLabel));\n\t\tthis._register(this.hoverService.setupManagedHover(getDefaultHoverDelegate('element'), hintElement, title));\n\n\t\tconst buttonMsg = this.attachment.enabled ? localize('disable', \"Disable current {0} context\", attachmentTypeName) : localize('enable', \"Enable current {0} context\", attachmentTypeName);\n\t\tconst toggleButton = this.renderDisposables.add(new Button(this.domNode, { supportIcons: true, title: buttonMsg }));\n\t\ttoggleButton.icon = this.attachment.enabled ? Codicon.eye : Codicon.eyeClosed;\n\t\tthis.renderDisposables.add(toggleButton.onDidClick((e) => {\n\t\t\te.stopPropagation(); // prevent it from triggering the click handler on the parent immediately after rerendering\n\t\t\tthis.attachment.enabled = !this.attachment.enabled;\nAfter:\nimport { ChatAttachmentModel } from '../chatAttachmentModel.js';\n\t\tprivate readonly attachmentModel: ChatAttachmentModel,\n\t\tthis.domNode.classList.add('disabled');\n\t\tconst range = undefined;\n\t\tconst ariaLabel = localize('chat.fileAttachment', \"Attached {0}, {1}\", attachmentTypeName, friendlyName);\n\t\tthis.renderDisposables.add(dom.addDisposableListener(this.domNode, dom.EventType.CLICK, e => {\n\t\t\tthis.convertToRegularAttachment();\n\n\tprivate convertToRegularAttachment(): void {\n\t\tif (!this.attachment.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst file = URI.isUri(this.attachment.value) ? this.attachment.value : this.attachment.value.uri;\n\t\tthis.attachmentModel.addFile(file);\n\t}\n\nFile: src/vs/workbench/contrib/chat/browser/chatInputPart.ts\nBefore:\n\t\t\tthis._register(this._implicitContext.onDidChangeValue(() => this._handleAttachedContextChange()));\n\t\tif (this.implicitContext?.value) {\n\t\t\tconst implicitPart = store.add(this.instantiationService.createInstance(ImplicitContextAttachmentWidget, this.implicitContext, this._contextResourceLabels));\n\t\t\tcontainer.appendChild(implicitPart.domNode);\n\t\t}\n\nAfter:\nimport { isEqual } from '../../../../base/common/resources.js';\n\t// private implicitPart: ImplicitContextAttachmentWidget | undefined;\n\t// private includedFiles = new Set<URI>();\n\tprivate recentlyRemovedAttachments = new Set<URI>();\n\n\t\tthis.recentlyRemovedAttachments.clear();\n\t\t\tthis._register(this._implicitContext.onDidChangeValue(() => {\n\t\t\t\tthis.recentlyRemovedAttachments.clear();\n\t\t\t\tthis._handleAttachedContextChange();\n\t\t\t}));\n\t\tconst implicitUri = this.implicitContext?.value;\n\t\tlet recentlyAttached = false;\n\n\t\tif (URI.isUri(implicitUri)) {\n\t\t\t// check if file exists in current attachments\n\t\t\trecentlyAttached = attachments.some(\n\t\t\t\t([, attachment]) => URI.isUri(attachment.value) && attachment.value.fsPath === implicitUri.fsPath\n\t\t\t);\n\n\t\t\t// if not found in attachments, check in recently removed attachments\n\t\t\tif (!recentlyAttached) {\n\t\t\t\trecentlyAttached = [...this.recentlyRemovedAttachments].some(removed => isEqual(removed, implicitUri));\n\t\t\t}\n\t\t}\n\n\t\tif (this.implicitContext?.value && URI.isUri(implicitUri) && !recentlyAttached) {\n\t\t\tconst implicitPart = store.add(this.instantiationService.createInstance(ImplicitContextAttachmentWidget, this.implicitContext, this._contextResourceLabels, this._attachmentModel));\n\t\t\tcontainer.appendChild(implicitPart.domNode);\n\t\t}\n\n\t\tif (URI.isUri(attachment.value)) {\n\t\t\tthis.recentlyRemovedAttachments.add(attachment.value);\n\t\t}\n\n\t\tthis.renderAttachedContext();\n\nFile: src/vs/workbench/contrib/chat/browser/contrib/chatImplicitContext.ts\nBefore:\nimport { basename, isEqual } from '../../../../../base/common/resources.js';\n\t\tconst selection = codeEditor?.getSelection();\n\t\tlet isSelection = false;\n\t\t\tlanguageId = model.getLanguageId();\n\t\t\tif (selection && !selection.isEmpty()) {\n\t\t\t\tnewValue = { uri: model.uri, range: selection } satisfies Location;\n\t\t\t\tisSelection = true;\n\t\t\t} else {\n\t\t\t\tconst visibleRanges = codeEditor?.getVisibleRanges();\n\t\t\t\tif (visibleRanges && visibleRanges.length > 0) {\n\t\t\t\t\t// Merge visible ranges. Maybe the reference value could actually be an array of Locations?\n\t\t\t\t\t// Something like a Location with an array of Ranges?\n\t\t\t\t\tlet range = visibleRanges[0];\n\t\t\t\t\tvisibleRanges.slice(1).forEach(r => {\n\t\t\t\t\t\trange = range.plusRange(r);\n\t\t\t\t\t});\n\t\t\t\t\tnewValue = { uri: model.uri, range } satisfies Location;\n\t\t\t\t} else {\n\t\t\t\t\tnewValue = model.uri;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst activeCell = notebookEditor.getActiveCell();\n\t\t\tif (activeCell) {\n\t\t\t\tconst codeEditor = this.codeEditorService.getActiveCodeEditor();\n\t\t\t\tconst selection = codeEditor?.getSelection();\n\t\t\t\tconst visibleRanges = codeEditor?.getVisibleRanges() || [];\n\t\t\t\tnewValue = activeCell.uri;\n\t\t\t\tif (isEqual(codeEditor?.getModel()?.uri, activeCell.uri)) {\n\t\t\t\t\tif (selection && !selection.isEmpty()) {\n\t\t\t\t\t\tnewValue = { uri: activeCell.uri, range: selection } satisfies Location;\n\t\t\t\t\t\tisSelection = true;\n\t\t\t\t\t} else if (visibleRanges.length > 0) {\n\t\t\t\t\t\t// Merge visible ranges. Maybe the reference value could actually be an array of Locations?\n\t\t\t\t\t\t// Something like a Location with an array of Ranges?\n\t\t\t\t\t\tlet range = visibleRanges[0];\n\t\t\t\t\t\tvisibleRanges.slice(1).forEach(r => {\n\t\t\t\t\t\t\trange = range.plusRange(r);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewValue = { uri: activeCell.uri, range } satisfies Location;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewValue = notebookEditor.textModel?.uri;\n\t\t\t}\n\tprivate _enabled = true;\nAfter:\nimport { basename } from '../../../../../base/common/resources.js';\n\t\tconst isSelection = false;\n\t\t\tnewValue = model.uri;\n\t\t\tnewValue = notebookEditor.textModel?.uri;\n\tprivate _enabled = false;\n\nFile: src/vs/workbench/contrib/chat/browser/media/chat.css\nAfter:\n.interactive-session .chat-attached-context .chat-attached-context-attachment.implicit.disabled:hover {\n\tcursor: pointer;\n\tborder-style: solid;\n}\n\n\n"
    },
    {
      "pr_number": 249450,
      "changes": "File: src/vs/workbench/contrib/chat/browser/chatAccessibilityProvider.ts\nBefore:\n\t\t\tinput = v.toolSpecificData?.kind === 'terminal' ? v.toolSpecificData.command : JSON.stringify(v.toolSpecificData.rawInput);\nAfter:\n\t\t\tinput = v.toolSpecificData?.kind === 'terminal'\n\t\t\t\t? v.toolSpecificData.command\n\t\t\t\t: v.toolSpecificData?.kind === 'extensions'\n\t\t\t\t\t? JSON.stringify(v.toolSpecificData.extensions)\n\t\t\t\t\t: JSON.stringify(v.toolSpecificData.rawInput);\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatExtensionsInstallToolSubPart.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from '../../../../../../base/browser/dom.js';\nimport { localize } from '../../../../../../nls.js';\nimport { IContextKeyService } from '../../../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../../../platform/instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../../../../../platform/keybinding/common/keybinding.js';\nimport { ChatContextKeys } from '../../../common/chatContextKeys.js';\nimport { IChatToolInvocation } from '../../../common/chatService.js';\nimport { CancelChatActionId } from '../../actions/chatExecuteActions.js';\nimport { AcceptToolConfirmationActionId } from '../../actions/chatToolActions.js';\nimport { IChatCodeBlockInfo, IChatWidgetService } from '../../chat.js';\nimport { ChatConfirmationWidget, IChatConfirmationButton } from '../chatConfirmationWidget.js';\nimport { IChatContentPartRenderContext } from '../chatContentParts.js';\nimport { ChatExtensionsContentPart } from '../chatExtensionsContentPart.js';\nimport { BaseChatToolInvocationSubPart } from './chatToolInvocationSubPart.js';\n\nexport class ExtensionsInstallConfirmationWidgetSubPart extends BaseChatToolInvocationSubPart {\n\tpublic readonly domNode: HTMLElement;\n\tpublic readonly codeblocks: IChatCodeBlockInfo[] = [];\n\n\tconstructor(\n\t\ttoolInvocation: IChatToolInvocation,\n\t\tcontext: IChatContentPartRenderContext,\n\t\t@IKeybindingService keybindingService: IKeybindingService,\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@IChatWidgetService chatWidgetService: IChatWidgetService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t) {\n\t\tsuper(toolInvocation);\n\n\t\tif (toolInvocation.toolSpecificData?.kind !== 'extensions') {\n\t\t\tthrow new Error('Tool specific data is missing or not of kind extensions');\n\t\t}\n\n\t\tthis.domNode = dom.$('');\n\t\tconst chatExtensionsContentPart = this._register(instantiationService.createInstance(ChatExtensionsContentPart, toolInvocation.toolSpecificData));\n\t\tthis._register(chatExtensionsContentPart.onDidChangeHeight(() => this._onDidChangeHeight.fire()));\n\t\tdom.append(this.domNode, chatExtensionsContentPart.domNode);\n\n\t\tif (toolInvocation.isConfirmed === undefined) {\n\t\t\tconst continueLabel = localize('continue', \"Continue\");\n\t\t\tconst continueKeybinding = keybindingService.lookupKeybinding(AcceptToolConfirmationActionId)?.getLabel();\n\t\t\tconst continueTooltip = continueKeybinding ? `${continueLabel} (${continueKeybinding})` : continueLabel;\n\n\t\t\tconst cancelLabel = localize('cancel', \"Cancel\");\n\t\t\tconst cancelKeybinding = keybindingService.lookupKeybinding(CancelChatActionId)?.getLabel();\n\t\t\tconst cancelTooltip = cancelKeybinding ? `${cancelLabel} (${cancelKeybinding})` : cancelLabel;\n\n\t\t\tconst buttons: IChatConfirmationButton[] = [\n\t\t\t\t{\n\t\t\t\t\tlabel: continueLabel,\n\t\t\t\t\tdata: true,\n\t\t\t\t\ttooltip: continueTooltip\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: cancelLabel,\n\t\t\t\t\tdata: false,\n\t\t\t\t\tisSecondary: true,\n\t\t\t\t\ttooltip: cancelTooltip\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tconst confirmWidget = this._register(instantiationService.createInstance(\n\t\t\t\tChatConfirmationWidget,\n\t\t\t\ttoolInvocation.confirmationMessages?.title ?? localize('installExtensions', \"Install Extensions\"),\n\t\t\t\tundefined,\n\t\t\t\ttoolInvocation.confirmationMessages?.message ?? localize('installExtensionsConfirmation', \"Click the Install button on the extension and then press Continue when finished.\"),\n\t\t\t\tbuttons,\n\t\t\t\tcontext.container,\n\t\t\t));\n\t\t\tthis._register(confirmWidget.onDidChangeHeight(() => this._onDidChangeHeight.fire()));\n\t\t\tdom.append(this.domNode, confirmWidget.domNode);\n\t\t\tthis._register(confirmWidget.onDidClick(button => {\n\t\t\t\ttoolInvocation.confirmed.complete(button.data);\n\t\t\t\tchatWidgetService.getWidgetBySessionId(context.element.sessionId)?.focusInput();\n\t\t\t}));\n\t\t\ttoolInvocation.confirmed.p.then(() => {\n\t\t\t\tChatContextKeys.Editing.hasToolConfirmation.bindTo(contextKeyService).set(false);\n\t\t\t\tthis._onNeedsRerender.fire();\n\t\t\t});\n\t\t}\n\n\t}\n}\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatToolInvocationPart.ts\nBefore:\n\t\tif (this.toolInvocation.kind === 'toolInvocation' && this.toolInvocation.confirmationMessages) {\n\t\t\tif (this.toolInvocation.toolSpecificData?.kind === 'terminal') {\n\t\t\t\treturn this.instantiationService.createInstance(TerminalConfirmationWidgetSubPart, this.toolInvocation, this.toolInvocation.toolSpecificData, this.context, this.renderer, this.editorPool, this.currentWidthDelegate, this.codeBlockStartIndex);\n\t\t\t} else {\n\t\t\t\treturn this.instantiationService.createInstance(ToolConfirmationSubPart, this.toolInvocation, this.context, this.renderer, this.editorPool, this.currentWidthDelegate, this.codeBlockModelCollection, this.codeBlockStartIndex);\nAfter:\nimport { ExtensionsInstallConfirmationWidgetSubPart } from './chatExtensionsInstallToolSubPart.js';\n\t\tif (this.toolInvocation.kind === 'toolInvocation') {\n\t\t\tif (this.toolInvocation.toolSpecificData?.kind === 'extensions') {\n\t\t\t\treturn this.instantiationService.createInstance(ExtensionsInstallConfirmationWidgetSubPart, this.toolInvocation, this.context);\n\t\t\t}\n\t\t\tif (this.toolInvocation.confirmationMessages) {\n\t\t\t\tif (this.toolInvocation.toolSpecificData?.kind === 'terminal') {\n\t\t\t\t\treturn this.instantiationService.createInstance(TerminalConfirmationWidgetSubPart, this.toolInvocation, this.toolInvocation.toolSpecificData, this.context, this.renderer, this.editorPool, this.currentWidthDelegate, this.codeBlockStartIndex);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.instantiationService.createInstance(ToolConfirmationSubPart, this.toolInvocation, this.context, this.renderer, this.editorPool, this.currentWidthDelegate, this.codeBlockModelCollection, this.codeBlockStartIndex);\n\t\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/chatResponseAccessibleView.ts\nBefore:\n\t\t\t\t\t\tinput = toolInvocation.toolSpecificData?.kind === 'terminal' ? toolInvocation.toolSpecificData.command : JSON.stringify(toolInvocation.toolSpecificData.rawInput);\nAfter:\n\t\t\t\t\t\tinput = toolInvocation.toolSpecificData?.kind === 'terminal'\n\t\t\t\t\t\t\t? toolInvocation.toolSpecificData.command\n\t\t\t\t\t\t\t: input = toolInvocation.toolSpecificData?.kind === 'extensions'\n\t\t\t\t\t\t\t\t? JSON.stringify(toolInvocation.toolSpecificData.extensions)\n\t\t\t\t\t\t\t\t: JSON.stringify(toolInvocation.toolSpecificData.rawInput);\n\nFile: src/vs/workbench/contrib/chat/common/chatProgressTypes/chatToolInvocation.ts\nBefore:\nimport { IChatTerminalToolInvocationData, IChatToolInputInvocationData, IChatToolInvocation, IChatToolInvocationSerialized } from '../chatService.js';\n\tpublic readonly toolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData;\nAfter:\nimport { IChatExtensionsContent, IChatTerminalToolInvocationData, IChatToolInputInvocationData, IChatToolInvocation, IChatToolInvocationSerialized } from '../chatService.js';\n\tpublic readonly toolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData | IChatExtensionsContent;\n\nFile: src/vs/workbench/contrib/chat/common/chatService.ts\nBefore:\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData;\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData;\nAfter:\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData | IChatExtensionsContent;\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData | IChatExtensionsContent;\n\nFile: src/vs/workbench/contrib/chat/common/languageModelToolsService.ts\nBefore:\nimport { IChatTerminalToolInvocationData, IChatToolInputInvocationData } from './chatService.js';\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData;\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData;\nAfter:\nimport { IChatExtensionsContent, IChatTerminalToolInvocationData, IChatToolInputInvocationData } from './chatService.js';\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData | IChatExtensionsContent;\n\ttoolSpecificData?: IChatTerminalToolInvocationData | IChatToolInputInvocationData | IChatExtensionsContent;\n\nFile: src/vs/workbench/contrib/extensions/browser/extensions.contribution.ts\nAfter:\nimport { InstallExtensionsTool, InstallExtensionsToolData } from '../common/installExtensionsTool.js';\n\n\t\tconst installExtensionsTool = instantiationService.createInstance(InstallExtensionsTool);\n\t\tthis._register(toolsService.registerToolData(InstallExtensionsToolData));\n\t\tthis._register(toolsService.registerToolImplementation(InstallExtensionsToolData.id, installExtensionsTool));\n\nFile: src/vs/workbench/contrib/extensions/common/installExtensionsTool.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { localize } from '../../../../nls.js';\nimport { areSameExtensions } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';\nimport { CountTokensCallback, IPreparedToolInvocation, IToolData, IToolImpl, IToolInvocation, IToolResult, ToolDataSource, ToolProgress } from '../../chat/common/languageModelToolsService.js';\nimport { IExtensionsWorkbenchService } from './extensions.js';\n\nexport const InstallExtensionsToolId = 'vscode_installExtensions';\n\nexport const InstallExtensionsToolData: IToolData = {\n\tid: InstallExtensionsToolId,\n\ttoolReferenceName: 'installExtensions',\n\tcanBeReferencedInPrompt: true,\n\tdisplayName: localize('installExtensionsTool.displayName', 'Install Extensions'),\n\tmodelDescription: localize('installExtensionsTool.modelDescription', \"This is a tool for installing extensions in Visual Studio Code. You should provide the list of extension ids to install, and the confirmation message that is shown to the user. The identifier of an extension is '\\${ publisher }.\\${ name }' for example: 'vscode.csharp'.\"),\n\tuserDescription: localize('installExtensionsTool.userDescription', 'Tool for installing extensions'),\n\tsource: ToolDataSource.Internal,\n\tinputSchema: {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tids: {\n\t\t\t\ttype: 'array',\n\t\t\t\titems: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t},\n\t\t\t\tdescription: 'The ids of the extensions to search for. The identifier of an extension is \\'\\${ publisher }.\\${ name }\\' for example: \\'vscode.csharp\\'.',\n\t\t\t},\n\t\t\tconfirmation: {\n\t\t\t\ttype: 'object',\n\t\t\t\tdescription: 'Defines the confirmation dialog shown to the user. This appears after displaying the list of extensions with their install buttons. The title and message should explain the purpose of the suggested extensions and guide the user to press the Install button on each extension they wish to install. The message should clearly instruct the user to click the Continue button after they have finished installing their chosen extensions to proceed. Extensions are not installed automatically - the user must explicitly install them.',\n\t\t\t\tproperties: {\n\t\t\t\t\ttitle: {\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: 'The title to display to the user.',\n\t\t\t\t\t},\n\t\t\t\t\tmessage: {\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: 'The message to display to the user.',\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n};\n\ntype InputParams = {\n\tids: string[];\n\tconfirmation: {\n\t\ttitle: string;\n\t\tmessage: string;\n\t};\n};\n\nexport class InstallExtensionsTool implements IToolImpl {\n\n\tconstructor(\n\t\t@IExtensionsWorkbenchService private readonly extensionsWorkbenchService: IExtensionsWorkbenchService,\n\t) { }\n\n\tasync prepareToolInvocation(parameters: InputParams, token: CancellationToken): Promise<IPreparedToolInvocation | undefined> {\n\t\treturn {\n\t\t\tconfirmationMessages: {\n\t\t\t\ttitle: parameters.confirmation?.title ?? localize('installExtensionsTool.confirmationTitle', 'Install Extensions'),\n\t\t\t\tmessage: parameters.confirmation?.message ?? localize('installExtensionsTool.confirmationMessage', 'These extensions are recommeded for you by Copilot.'),\n\t\t\t},\n\t\t\ttoolSpecificData: {\n\t\t\t\tkind: 'extensions',\n\t\t\t\textensions: parameters.ids\n\t\t\t}\n\t\t};\n\t}\n\n\tasync invoke(invocation: IToolInvocation, _countTokens: CountTokensCallback, _progress: ToolProgress, token: CancellationToken): Promise<IToolResult> {\n\t\tconst input = invocation.parameters as InputParams;\n\t\tconst installed = this.extensionsWorkbenchService.local.filter(e => input.ids.some(id => areSameExtensions({ id }, e.identifier)));\n\t\treturn {\n\t\t\tcontent: [{\n\t\t\t\tkind: 'text',\n\t\t\t\tvalue: localize('installExtensionsTool.resultMessage', 'Following extensions are installed: {0}', installed.map(e => e.identifier.id).join(', ')),\n\t\t\t}]\n\t\t};\n\t}\n}\n\n\n"
    }
  ]
}