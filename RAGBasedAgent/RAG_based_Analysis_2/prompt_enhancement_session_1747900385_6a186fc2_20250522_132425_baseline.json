{
  "timestamp": "20250522_132425",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly precise and thorough expert code reviewer. Your task is to provide a comprehensive and actionable review of the provided code changes, focusing on technical accuracy and completeness.  Your feedback must be meticulously grounded in the code itself, referencing specific files, functions, and line numbers for every suggestion.  Avoid making assumptions; all feedback must be directly supported by evidence from the code.\n\n**Technical Accuracy & Completeness:** Analyze all modified files and their dependencies. For each change, explain its impact on functionality, performance, and maintainability.  This includes detailing potential side effects, edge cases, and error handling.  Quantify your assessments wherever possible (e.g., \"This change increases execution time by X%\").  Clearly articulate any missing tests or necessary additions to ensure comprehensive test coverage.  Explicitly state the expected behavior and how the changes contribute to or deviate from that expectation.\n\n**Faithfulness & Contextual Precision:**  Every suggestion must be directly traceable to the provided code.  Avoid generic or speculative feedback.  Accurately reflect the code's context and intent.  If a change is unclear or lacks sufficient context, explicitly state that and explain why further information is needed.  If assumptions are necessary, clearly label them as such and explain the rationale.\n\n**Actionable Suggestions:** Your feedback should be practical and implementation-ready.  Suggest concrete solutions to identified issues, including specific code snippets whenever possible. Structure your review clearly and logically, separating distinct issues with appropriate headings and subheadings. Use a consistent and easily understandable format to facilitate quick comprehension and efficient implementation of your recommendations. Prioritize suggestions based on their potential impact.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.7223913669586182,
      "Accuracy": 0.9,
      "Groundedness": 0.8,
      "Completeness": 0.4,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.3,
      "AnswerRelevance": 0.53,
      "BLEU": 0.07126955677090929,
      "ROUGE": 0.14213197969543145,
      "Overall": 0.587
    },
    "llama": {
      "Relevance": 0.7832369804382324,
      "Accuracy": 0.9,
      "Groundedness": 0.8,
      "Completeness": 0.4,
      "Faithfulness": 0.0,
      "ContextualPrecision": 0.6,
      "AnswerRelevance": 0.8799999999999999,
      "BLEU": 0.17404981427916244,
      "ROUGE": 0.22487223168654175,
      "Overall": 0.625
    },
    "alibaba": {
      "Relevance": 0.7534303069114685,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.2,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.3,
      "AnswerRelevance": 0.27,
      "BLEU": 0.0786632387311625,
      "ROUGE": 0.17161716171617164,
      "Overall": 0.517
    }
  },
  "best_model": "llama",
  "baseline_review": "# Summary\n\nThe current pull request (PR) involves refactoring the code to use a new `attachPrompt` function instead of the existing `attachPrompts` function. The main goal is to modify the attachment logic to handle individual files and provide more detailed information about the attachment process.\n\n## Key Changes\n\n*   Replaced `attachPrompts` with `attachPrompt` to handle individual file attachments.\n*   Introduced a new `detachPrompt` function to detach prompts from a chat input.\n*   Modified the `add` method in `chatPromptAttachmentsCollection.ts` to return a boolean indicating whether the attachment already exists.\n\n## Purpose\n\nThe purpose of these changes is to improve the attachment logic and provide more granular control over file attachments in the chat functionality.\n\n# File Changes\n\nThe following files require updates:\n\n1.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts**\n\n    *   Before: `import { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';`\n    *   After: `import { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';`\n    *   Impact: Replaced `attachPrompts` with `attachPrompt` to handle individual file attachments.\n\n2.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts**\n\n    *   Before: `import { runAttachPromptAction } from './chatAttachPromptAction.js';`\n    *   After: `import { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js'; import { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';`\n    *   Impact: Introduced new `attachPrompt` and `detachPrompt` functions.\n\n3.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts**\n\n    *   Before: `import { attachPrompts } from './utils/attachPrompts.js';`\n    *   After: `import { attachPrompt } from './utils/attachPrompt.js';`\n    *   Impact: Replaced `attachPrompts` with `attachPrompt` for individual file attachments.\n\n4.  **src/vs/workbench/contrib/chat/browser/actions",
  "session_id": "session_1747900385_6a186fc2",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249473,
      "changes": "File: src/vs/workbench/contrib/chat/browser/attachments/implicitContextAttachment.ts\nBefore:\nimport { Button } from '../../../../../base/browser/ui/button/button.js';\nimport { getDefaultHoverDelegate } from '../../../../../base/browser/ui/hover/hoverDelegateFactory.js';\nimport { IHoverService } from '../../../../../platform/hover/browser/hover.js';\n\t\t@IHoverService private readonly hoverService: IHoverService,\n\t\tthis.domNode.classList.toggle('disabled', !this.attachment.enabled);\n\t\tconst range = URI.isUri(this.attachment.value) || !this.attachment.isSelection ? undefined : this.attachment.value!.range;\n\t\tconst ariaLabel = range ? localize('chat.fileAttachmentWithRange', \"Attached {0}, {1}, line {2} to line {3}\", attachmentTypeName, friendlyName, range.startLineNumber, range.endLineNumber) : localize('chat.fileAttachment', \"Attached {0}, {1}\", attachmentTypeName, friendlyName);\n\t\tconst hintLabel = localize('hint.label.current', \"Current {0}\", attachmentTypeName);\n\t\tconst hintElement = dom.append(this.domNode, dom.$('span.chat-implicit-hint', undefined, hintLabel));\n\t\tthis._register(this.hoverService.setupManagedHover(getDefaultHoverDelegate('element'), hintElement, title));\n\n\t\tconst buttonMsg = this.attachment.enabled ? localize('disable', \"Disable current {0} context\", attachmentTypeName) : localize('enable', \"Enable current {0} context\", attachmentTypeName);\n\t\tconst toggleButton = this.renderDisposables.add(new Button(this.domNode, { supportIcons: true, title: buttonMsg }));\n\t\ttoggleButton.icon = this.attachment.enabled ? Codicon.eye : Codicon.eyeClosed;\n\t\tthis.renderDisposables.add(toggleButton.onDidClick((e) => {\n\t\t\te.stopPropagation(); // prevent it from triggering the click handler on the parent immediately after rerendering\n\t\t\tthis.attachment.enabled = !this.attachment.enabled;\nAfter:\nimport { ChatAttachmentModel } from '../chatAttachmentModel.js';\n\t\tprivate readonly attachmentModel: ChatAttachmentModel,\n\t\tthis.domNode.classList.add('disabled');\n\t\tconst range ...[truncated]"
    },
    {
      "pr_number": 249497,
      "changes": "File: src/vs/workbench/api/common/extHostLanguageModelTools.ts\nBefore:\n\t\t\t\t\ttitle: result.confirmationMessages.title,\n\t\t\t\t\ttitle: result.confirmationMessages.title,\nAfter:\n\t\t\t\t\ttitle: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),\n\t\t\t\t\ttitle: typeof result.confirmationMessages.title === 'string' ? result.confirmationMessages.title : typeConvert.MarkdownString.from(result.confirmationMessages.title),\n\nFile: src/vs/workbench/contrib/chat/browser/chatAccessibilityProvider.ts\nBefore:\n\t\t\t\t\ttoolInvocationHint += localize('toolCompletedHint', \"Tool {0} completed.\", invocation.confirmationMessages?.title);\nAfter:\n\t\t\t\t\ttoolInvocationHint += localize('toolCompletedHint', \"Tool {0} completed.\", typeof invocation.confirmationMessages?.title === 'string' ? invocation.confirmationMessages?.title : invocation.confirmationMessages?.title.value);\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/chatConfirmationWidget.ts\nBefore:\n\t\ttitle: string,\n\t\ttitle: string,\n\t\ttitle: string,\nAfter:\n\t\ttitle: string | IMarkdownString,\n\t\ttitle: string | IMarkdownString,\n\t\ttitle: string | IMarkdownString,\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatTerminalToolSubPart.ts\nBefore:\n\t\t\t\tariaLabel: title\nAfter:\n\t\t\t\tariaLabel: typeof title === 'string' ? title : title.value\n\nFile: src/vs/workbench/contrib/chat/browser/chatContentParts/toolInvocationParts/chatToolConfirmationSubPart.ts\nBefore:\n\t\t\t\t\tariaLabel: title\n\t\t\t\t\t\tariaLabel: toolInvocation.confirmationMessages.title\nAfter:\n\t\t\t\t\tariaLabel: typeof title === 'string' ? title : title.value\n\t\t\t\t\t\tariaLabel: typeof toolInvocation.confirmationMessages.title === 'string' ? toolInvocation.confirmationMessages.title : toolInvocation.confirmationMessages.title.value\n\nFile: src/vs/workbench/contrib/chat/browser/languageModelToolsService.ts\nBefore:\n\t\t\t\t\tconst result = await this._dialogService.conf...[truncated]"
    },
    {
      "pr_number": 249469,
      "changes": "File: src/vs/workbench/contrib/chat/browser/chatWidget.ts\nBefore:\nimport { pick } from '../../../../base/common/arrays.js';\nimport { isLocation, Location } from '../../../../editor/common/languages.js';\n\t\tif (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(toUri(variable), promptPath.uri))) {\n\t\t\t.filter(pick('isRoot'));\n\t\tconst promptUris = promptFileVariables.map(toUri);\n\t\tassert(\n\t\t\tthis.inputPart.currentMode === ChatMode.Agent,\n\t\t\t`Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`,\n\t\t);\n\t\t\t.map(pick('id'));\n\t\t\t.filter(hasAddressableValue)\n\t\t\t.map(toUri);\n/**\n * Type for any \"addressable\" object - i.e., an object that has\n * the `value` property that is either a {@link URI} or a {@link Location}.\n */\nexport type TAddressable<T extends object> = T & { value: URI | Location };\n\n/**\n * Check if provided object is \"addressable\" - i.e., has the `value`\n * property that is either a {@link URI} or a {@link Location}.\n */\nconst hasAddressableValue = <T extends object>(\n\tthing: T,\n): thing is TAddressable<T> => {\n\tif ((!thing) || (('value' in thing) === false)) {\n\t\treturn false;\n\t}\n\n\tif (URI.isUri(thing.value) || isLocation(thing.value)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Returns URI of a provided \"addressable\" object.\n */\nconst toUri = <T extends object>(\n\tthing: TAddressable<T>,\n): URI => {\n\tconst { value } = thing;\n\n\treturn URI.isUri(value)\n\t\t? value\n\t\t: value.uri;\n};\nAfter:\n\t\tif (!attachedContext.some(variable => isPromptFileChatVariable(variable) && isEqual(IChatRequestVariableEntry.toUri(variable), promptPath.uri))) {\n\t\t\t.filter(e => e.isRoot);\n\t\tconst promptUris = promptFileVariables.map(IChatRequestVariableEntry.toUri).filter(isDefined);\n\t\t\t// NOTE this is a prompt and therefore not localized\n\t\tassert(this.inputPart.currentMode === ChatMode.Agent, `Chat mode must be 'agent' when there are 'tools' defined, got ${this.inputPart.currentMode}.`);\n\n\t\t\t.map(tool => tool.id);\n\n\t\t\t.map(...[truncated]"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}