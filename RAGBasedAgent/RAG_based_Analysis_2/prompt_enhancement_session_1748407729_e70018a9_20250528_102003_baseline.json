{
  "timestamp": "20250528_102003",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly meticulous and technically proficient code reviewer. Your task is to provide a comprehensive and actionable review of the submitted code changes.  Prioritize accuracy and completeness, ensuring all feedback is directly grounded in the provided codebase.\n\n**I. Technical Accuracy & Contextual Precision:** For each identified issue, provide: (a) the specific file name, function name, and line numbers; (b) a precise description of the issue, including its potential impact on functionality, performance, security, or maintainability; (c) a clear explanation of how the issue relates to the surrounding code context and its intended behavior; (d)  concrete suggestions for improvement, including specific code snippets where applicable.  Avoid vague or generalized feedback.\n\n**II. Completeness & Context Recall:** Systematically review all changed files and their dependencies.  Address every modification, however minor, ensuring no aspect is overlooked.  Analyze the potential impact of each change on related components and consider downstream effects.  Explicitly mention any untested code sections or areas requiring additional test cases.  Your review must demonstrate a thorough understanding of the codebase's overall architecture and functionality.\n\n**III. Groundedness, Faithfulness, & Answer Relevance:**  Base all your suggestions solely on the provided code and accompanying documentation. Avoid making assumptions or speculating about the developer's intentions without concrete evidence from the code itself.  Every comment must be directly traceable to a specific line or code section.  Ensure all feedback is directly relevant to the submitted changes and avoids unrelated or tangential observations.\n\n**IV.  Actionable Suggestions & Structure:**  Provide practical, implementation-ready suggestions.  Structure your review logically, using clear headings and bullet points to organize your feedback. Prioritize clarity and conciseness, facilitating easy understanding and implementation for the developer.  Use a consistent and professional tone.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.6470011472702026,
      "Accuracy": 0.8,
      "Groundedness": 0.3875,
      "Completeness": 0.2,
      "Faithfulness": 0.3875,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.46069364161849713,
      "BLEU": 0.029164959724530218,
      "ROUGE": 0.18140589569160998,
      "Overall": 0.47653281846762213
    },
    "llama": {
      "Relevance": 0.6489248275756836,
      "Accuracy": 0.9,
      "Groundedness": 0.4191011235955056,
      "Completeness": 0.3,
      "Faithfulness": 0.4191011235955056,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4805243445692884,
      "BLEU": 0.26643876742686545,
      "ROUGE": 0.3345280764635603,
      "Overall": 0.5407321841141525
    },
    "alibaba": {
      "Relevance": 0.5127744078636169,
      "Accuracy": 0.8,
      "Groundedness": 0.38875739644970414,
      "Completeness": 0.2,
      "Faithfulness": 0.38875739644970414,
      "ContextualPrecision": 0.6,
      "ContextRecall": 0.6,
      "AnswerRelevance": 0.4654069767441861,
      "BLEU": 0.03468317761317914,
      "ROUGE": 0.15503875968992248,
      "Overall": 0.44960350423944734
    }
  },
  "best_model": "llama",
  "baseline_review": "## Analysis of the PR\n\n### Summary - Key Changes and Their Purpose\n\nThe current PR involves refactoring the code related to attaching and detaching prompts in the chat functionality. The key changes include:\n\n*   Renaming and refactoring the `attachPrompts` function to `attachPrompt` to handle single file attachments.\n*   Introducing a new `detachPrompt` function to detach prompts from a chat input.\n*   Updating various files to use the new `attachPrompt` and `detachPrompt` functions.\n\nThe purpose of these changes is to improve the handling of single file attachments and to provide a more granular control over attaching and detaching prompts.\n\n### File Changes - Specific Files Needing Updates\n\nThe following files need updates:\n\n*   `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts`\n*   `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts`\n*   `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts`\n*   `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts`\n*   `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts`\n*   `src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts`\n\n### Conflicts - Files with High Change Frequency\n\nBased on the provided similar PRs, the following files have high change frequency:\n\n*   `src/vs/workbench/contrib/chat/browser/actions/chatToolActions.ts`\n*   `src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts`\n*   `src/vs/workbench/contrib/chat/browser/chatInputPart.ts`\n*   `src/vs/workbench/contrib/chat/browser/chatSelectedTools.ts`\n\nThese files may require additional attention during the review process.\n\n### Risks - Potential Breaking Changes with Evidence\n\nThe following changes may introduce potential breaking changes:\n\n*   In `src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts`, the `add` method in `chatPromptAttachmentsCollection.ts` now returns a boolean indicating whether the attachment already exists. This change may affect existing code that relies on the previous behavior.\n\n    ```typescript",
  "session_id": "session_1748407729_e70018a9",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 249878,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatToolActions.ts\nBefore:\n\t\t\twidget.input.selectedToolsModel.update(disableToolSets, disableTools);\n\n\nAfter:\n\t\t\twidget.input.selectedToolsModel.disable(disableToolSets, disableTools, false);\n\nFile: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\tonUpdate?.(result);\nAfter:\n\t\t\tif (onUpdate) {\n\t\t\t\tlet didChange = toolsEntries.size !== result.size;\n\t\t\t\tfor (const [key, value] of toolsEntries) {\n\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdidChange = result.get(key) !== value;\n\t\t\t\t}\n\n\t\t\t\tif (didChange) {\n\t\t\t\t\tonUpdate(result);\n\t\t\t\t}\n\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/chatInputPart.ts\nAfter:\n\t\tthis.selectedToolsModel.resetSessionEnablementState();\n\n\nFile: src/vs/workbench/contrib/chat/browser/chatSelectedTools.ts\nBefore:\nimport { autorun, IObservable, observableFromEvent, ObservableMap, transaction } from '../../../../base/common/observable.js';\n\tdisabledToolSets?: readonly string[];\n\tdisabledTools?: readonly string[];\n\t\t@ILanguageModelToolsService toolsService: ILanguageModelToolsService,\n\t\tthis._allTools = observableFromEvent(toolsService.onDidChangeTools, () => Array.from(toolsService.getTools()));\n\t\tconst disabledDataObs = this._selectedTools.map(data => {\n\t\t\treturn (data.disabledToolSets?.length || data.disabledTools?.length)\n\t\t\t\t? {\n\t\t\t\t\ttoolSetIds: new Set(data.disabledToolSets),\n\t\t\t\t\ttoolIds: new Set(data.disabledTools),\n\t\t\t\t: undefined;\n\t\t\tconst toolSets = toolsService.toolSets.read(r);\n\t\t\t\t\t// only homogenous tool sets can shallow tools\n\tselectOnly(toolIds: readonly string[]): void {\n\t\tconst uniqueTools = new Set(toolIds);\n\t\tconst disabledTools = this._allTools.get().filter(tool => !uniqueTools.has(tool.id));\n\t\tthis.update([], disabledTools);\n\tupdate(disabledToolSets: readonly ToolSet[], disableTools: readonly IToolData[]): void {\n\t\tthis._selectedTools.set({\nAfter:\nimport { autorun, derived, IObservable, observableFromEvent, ObservableMap, observableValue, transacti...[truncated]"
    },
    {
      "pr_number": 249895,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatContext.ts\nBefore:\n\nAfter:\n\t\t\tif (res === 0) {\n\t\t\t\tres = a.toolInfo.label.localeCompare(b.toolInfo.label);\n\t\t\t}\n\nFile: src/vs/workbench/contrib/chat/browser/actions/chatToolPicker.ts\nBefore:\n\t\t\t\tlabel: toolSetOrTool.source.label,\nAfter:\n\t\t\t\tlabel: localize('ext', 'Extension: {0}', toolSetOrTool.source.label),\n\nFile: src/vs/workbench/contrib/chat/common/languageModelToolsService.ts\nBefore:\n\t\t\treturn { ordinal: 3, label: 'Built-In' };\n\t\t\treturn { ordinal: 1, label: 'MCP Servers' };\n\t\t\treturn { ordinal: 0, label: 'User Defined' };\n\t\t\treturn { ordinal: 2, label: 'Extensions' };\nAfter:\nimport { localize } from '../../../../nls.js';\n\t\t\treturn { ordinal: 1, label: localize('builtin', 'Built-In') };\n\t\t\treturn { ordinal: 2, label: localize('mcp', 'MCP Server: {0}', source.label) };\n\t\t\treturn { ordinal: 0, label: localize('user', 'User Defined') };\n\t\t\treturn { ordinal: 3, label: localize('ext', 'Extension: {0}', source.label) };\n\n"
    },
    {
      "pr_number": 249894,
      "changes": "File: src/vs/workbench/contrib/chat/browser/chatAttachmentWidgets.ts\nBefore:\nimport { IChatRequestPasteVariableEntry, IChatRequestVariableEntry, IElementVariableEntry, INotebookOutputVariableEntry, ISCMHistoryItemVariableEntry, OmittedState } from '../common/chatModel.js';\nAfter:\nimport { IChatRequestPasteVariableEntry, IChatRequestToolEntry, IChatRequestToolSetEntry, IChatRequestVariableEntry, IElementVariableEntry, INotebookOutputVariableEntry, ISCMHistoryItemVariableEntry, OmittedState } from '../common/chatModel.js';\nimport { ILanguageModelToolsService, ToolSet } from '../common/languageModelToolsService.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nexport class ToolSetOrToolItemAttachmentWidget extends AbstractChatAttachmentWidget {\n\tconstructor(\n\t\tattachment: IChatRequestToolSetEntry | IChatRequestToolEntry,\n\t\tcurrentLanguageModel: ILanguageModelChatMetadataAndIdentifier | undefined,\n\t\toptions: { shouldFocusClearButton: boolean; supportsDeletion: boolean },\n\t\tcontainer: HTMLElement,\n\t\tcontextResourceLabels: ResourceLabels,\n\t\thoverDelegate: IHoverDelegate,\n\t\t@ILanguageModelToolsService toolsService: ILanguageModelToolsService,\n\t\t@ICommandService commandService: ICommandService,\n\t\t@IOpenerService openerService: IOpenerService,\n\t\t@IHoverService hoverService: IHoverService\n\t) {\n\t\tsuper(attachment, options, container, contextResourceLabels, hoverDelegate, currentLanguageModel, commandService, openerService);\n\n\n\t\tconst toolOrToolSet = Iterable.find(toolsService.getTools(), tool => tool.id === attachment.id) ?? Iterable.find(toolsService.toolSets.get(), toolSet => toolSet.id === attachment.id);\n\n\t\tlet name = attachment.name;\n\t\tconst icon = attachment.icon ?? Codicon.tools;\n\n\t\tif (toolOrToolSet) {\n\t\t\tname = toolOrToolSet.toolReferenceName ?? name;\n\t\t}\n\n\t\tthis.label.setLabel(`$(${icon.id})\\u00A0${name}`, undefined);\n\n\t\tthis.element.style.cursor = 'pointer';\n\t\tthis.element.ariaLabel = localize('chat.attachment', \"Attached context, {0}\", name);\n\n\t\t...[truncated]"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}