{
  "timestamp": "20250419_185829",
  "original_system_prompt": "You are an expert code reviewer. Provide detailed, actionable feedback:\n\n1. Technical Accuracy\n- Reference specific files, functions, and line numbers\n- Explain the impact of each change\n- Ground suggestions in the code context\n\n2. Completeness\n- Cover all changed files and their dependencies\n- Analyze potential impacts thoroughly\n- Include test coverage requirements\n\n3. Faithfulness\n- Base all suggestions on the actual code\n- Avoid assumptions without evidence\n- Link suggestions to specific code patterns\n\nKeep suggestions practical and implementation-ready.",
  "enhanced_system_prompt": "You are a highly precise and thorough code reviewer. Your task is to provide a comprehensive and actionable review of the provided code changes, focusing on technical accuracy, completeness, and faithfulness.  Your feedback must be grounded in the code itself, referencing specific files, functions, and line numbers whenever possible.  \n\n**Technical Accuracy & Completeness:** For each changed file, meticulously analyze the code modifications.  Clearly explain the impact of each change, including its intended functionality and potential side effects. Identify any areas where the code is unclear, inefficient, or potentially buggy.  Thoroughly examine dependencies between changed files, and address any inconsistencies or conflicts.  Your analysis must cover all changed files and their relevant dependencies, leaving no aspect unexamined.  Specify required test cases to ensure complete coverage of the changes.\n\n**Faithfulness & Groundedness:**  Base all your suggestions directly on the provided code.  Avoid making assumptions; your feedback must be demonstrably linked to specific code patterns and behaviors.  For each suggestion, provide a clear and concise explanation of its rationale, citing the corresponding code lines and justifying its necessity.  Ensure your assessment is firmly rooted in the code's actual functionality and avoids speculation.\n\n**Actionable Suggestions:** Frame your feedback with practical and implementation-ready suggestions.  Propose concrete solutions to identified issues, offering clear and concise code examples where necessary.  Prioritize clarity and conciseness in your explanations, ensuring the suggestions are easily understood and implemented by developers.\n\n**Structure & Organization:**  Structure your review logically and systematically.  Begin with an overview of the changes, followed by a file-by-file analysis with detailed line-by-line feedback where needed. Use headings and bullet points to clearly delineate different sections and suggestions.  Your review should be easily navigable and understandable.",
  "baseline_metrics": {
    "deepseek": {
      "Relevance": 0.5504280924797058,
      "Accuracy": 0.8,
      "Groundedness": 0.8,
      "Completeness": 0.3,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.8,
      "AnswerRelevance": 0.33999999999999997,
      "BLEU": 0.049323515694897097,
      "ROUGE": 0.1858325666973321,
      "Overall": 0.595
    },
    "llama": {
      "Relevance": 0.7087035179138184,
      "Accuracy": 0.8,
      "Groundedness": 0.7,
      "Completeness": 0.3,
      "Faithfulness": 0.25,
      "ContextualPrecision": 1.0,
      "AnswerRelevance": 0.75,
      "BLEU": 0.18144138015023187,
      "ROUGE": 0.261116367076632,
      "Overall": 0.61
    },
    "alibaba": {
      "Relevance": 0.854640007019043,
      "Accuracy": 0.9,
      "Groundedness": 0.8,
      "Completeness": 0.3,
      "Faithfulness": 0.5,
      "ContextualPrecision": 0.0,
      "AnswerRelevance": 0.27,
      "BLEU": 0.0336131839383324,
      "ROUGE": 0.15978456014362658,
      "Overall": 0.532
    }
  },
  "best_model": "llama",
  "baseline_review": "## Summary\n\nThe provided Pull Request (PR) appears to refactor the chat attachment and prompt functionality. The key changes include:\n\n*   Refactoring `attachPrompts` to `attachPrompt` to handle single file attachments\n*   Introduction of `detachPrompt` to detach prompts from chat inputs\n*   Modifying `chatAttachPromptAction` and `chatRunPromptAction` to utilize the new `attachPrompt` and `detachPrompt` functions\n\nThe purpose of these changes seems to be to improve the handling of file attachments in chat prompts, making the code more modular and efficient.\n\n## File Changes\n\nThe following files require updates:\n\n1.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts**\n\n    *   Before: `import { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';`\n    *   After: `import { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';`\n    *   Impact: Replaces `attachPrompts` with `attachPrompt` to handle single file attachments.\n\n2.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts**\n\n    *   Before: `import { runAttachPromptAction } from './chatAttachPromptAction.js';`\n    *   After: `import { IChatWidget } from '../../chat.js'; import { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js'; import { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';`\n    *   Impact: Introduces `attachPrompt` and `detachPrompt` to manage prompt attachments.\n\n3.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts**\n\n    *   Before: `import { attachPrompts } from './utils/attachPrompts.js';`\n    *   After: `import { attachPrompt } from './utils/attachPrompt.js';`\n    *   Impact: Replaces `attachPrompts` with `attachPrompt` for single file handling.\n\n4.  **src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts**\n\n    *   Before:",
  "session_id": "session_1745069232_3e2c214a",
  "current_pr_changes": "File: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts\nBefore:\nimport { attachPrompts, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompts.js';\n\t\t\tconst widget = await attachPrompts(\n\t\t\t\t[{ value: resource }],\nAfter:\nimport { attachPrompt, IAttachPromptOptions } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\n\t\t\tconst { widget } = await attachPrompt(\n\t\t\t\tresource,\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts\nBefore:\nimport { runAttachPromptAction } from './chatAttachPromptAction.js';\n\t): Promise<void> {\n\t\treturn await runAttachPromptAction({\n\t\t\tinNewChat,\n\t\t\tskipSelectionDialog: true,\n\t\t}, commandService);\n\t): Promise<void> {\n\t): Promise<void> {\nAfter:\nimport { IChatWidget } from '../../chat.js';\nimport { attachPrompt } from './dialogs/askToSelectPrompt/utils/attachPrompt.js';\nimport { detachPrompt } from './dialogs/askToSelectPrompt/utils/detachPrompt.js';\nimport { IViewsService } from '../../../../../services/views/common/viewsService.js';\n\t): Promise<IChatWidget> {\n\t\tconst viewsService = accessor.get(IViewsService);\n\t\tconst { widget, wasAlreadyAttached } = await attachPrompt(\n\t\t\t{\n\t\t\t\tinNewChat,\n\t\t\t\tcommandService,\n\t\t\t\tviewsService,\n\t\t\t},\n\t\t);\n\n\t\t// submit the prompt immediately\n\t\tawait widget.acceptInput();\n\n\t\t// detach the prompt immediately, unless was attached\n\t\t// before the action was executed\n\t\tif (wasAlreadyAttached === false) {\n\t\t\tawait detachPrompt(resource, { widget });\n\t\t}\n\n\t\treturn widget;\n\t): Promise<IChatWidget> {\n\t): Promise<IChatWidget> {\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts\nBefore:\nimport { attachPrompts } from './utils/attachPrompts.js';\n\t\t\tlastActiveWidget = await attachPrompts(\n\t\t\t\tselectedItems,\nAfter:\nimport { attachPrompt } from './utils/attachPrompt.js';\n\t\t\tconst attachResult = await attachPrompt(\n\t\t\t\tselectedOption.value,\n\t\t\tlastActiveWidget = attachResult.widget;\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts\nBefore:\nimport { assertDefined, WithUriValue } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompts} function.\nexport const attachPrompts = async (\n\tfiles: readonly WithUriValue<Object>[],\n): Promise<IChatWidget> => {\n\tfor (const file of files) {\n\t\twidget\n\t\t\t.attachmentModel\n\t\t\t.promptInstructions\n\t\t\t.add(file.value);\n\t}\n\treturn widget;\nAfter:\nimport { URI } from '../../../../../../../../../base/common/uri.js';\nimport { assertDefined } from '../../../../../../../../../base/common/types.js';\n * Options for the {@link attachPrompt} function.\n/**\n * Return value of the {@link attachPrompt} function.\n */\ninterface IAttachResult {\n\treadonly widget: IChatWidget;\n\treadonly wasAlreadyAttached: boolean;\n}\n\nexport const attachPrompt = async (\n\tfile: URI,\n): Promise<IAttachResult> => {\n\tconst wasAlreadyAttached = widget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.add(file);\n\treturn { widget, wasAlreadyAttached };\n\nFile: src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts\nAfter:\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChatWidget } from '../../../../../chat.js';\nimport { URI } from '../../../../../../../../../base/common/uri.js';\n\n/**\n * Options for the {@link detachPrompt} function.\n */\nexport interface IDetachPromptOptions {\n\t/**\n\t * Chat widget instance to attach the prompt to.\n\t */\n\treadonly widget: IChatWidget;\n}\n\n/**\n * Detaches provided prompts to a chat input.\n */\nexport const detachPrompt = async (\n\tfile: URI,\n\toptions: IDetachPromptOptions,\n): Promise<IChatWidget> => {\n\tconst { widget } = options;\n\n\twidget\n\t\t.attachmentModel\n\t\t.promptInstructions\n\t\t.remove(file);\n\n\treturn widget;\n};\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts\nBefore:\n\tpublic add(uri: URI): this {\n\t\t\treturn this;\n\t\treturn this;\nAfter:\n\t *\n\t * @returns `true` if the attachment already exists, `false` otherwise.\n\tpublic add(uri: URI): boolean {\n\t\t\treturn true;\n\t\treturn false;\n\n",
  "similar_prs_changes": [
    {
      "pr_number": 246891,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatActions.ts\nBefore:\n\t\t\t\tmessage = localize('chatQuotaExceeded', \"You've reached your monthly chat messages quota. You still have free code completions available.\");\n\t\t\t\tmessage = localize('completionsQuotaExceeded', \"You've reached your monthly code completions quota. You still have free chat messages available.\");\n\t\t\t\tmessage = localize('chatAndCompletionsQuotaExceeded', \"You've reached your monthly chat messages and code completions quota.\");\n\t\t\tconst upgradeToPro = limited ? localize('upgradeToPro', \"Upgrade to Copilot Pro (your first 30 days are free) for:\\n- Unlimited code completions\\n- Unlimited basic chat messages\\n- Access to premium models\") : undefined;\n\t\t\t\t\tprimaryActionTitle = localize('chatQuotaExceededButton', \"Copilot Free plan chat messages quota reached. Click for details.\");\nAfter:\n\t\t\t\tmessage = localize('chatQuotaExceeded', \"You've reached your monthly chat requests quota. You still have free code completions available.\");\n\t\t\t\tmessage = localize('completionsQuotaExceeded', \"You've reached your monthly code completions quota. You still have free chat requests available.\");\n\t\t\t\tmessage = localize('chatAndCompletionsQuotaExceeded', \"You've reached your monthly chat requests and code completions quota.\");\n\t\t\tconst upgradeToPro = limited ? localize('upgradeToPro', \"Upgrade to Copilot Pro (your first 30 days are free) for:\\n- Unlimited code completions\\n- Unlimited basic chat requests\\n- Access to premium models\") : undefined;\n\t\t\t\t\tprimaryActionTitle = localize('chatQuotaExceededButton', \"Copilot Free plan chat requests quota reached. Click for details.\");\n\nFile: src/vs/workbench/contrib/chat/browser/chatStatus.ts\nBefore:\n\t\t\tconst completionsQuotaIndicator = completionsQuota ? this.createQuotaIndicator(this.element, completionsQuota, localize('completionsLabel', \"Code completions\")) : undefined;\n\t\t\tconst chatQuotaIndicator = chatQuota ? this.createQuotaIndicator(this.element, chatQuota, localize('c...[truncated]"
    },
    {
      "pr_number": 246931,
      "changes": "File: src/vs/editor/common/codecs/markdownCodec/parsers/markdownLink.ts\nBefore:\n * into the {@linkcode MarkdownLinkCaption} parser type which continues the general\n * Otherwise, if one of the stop characters defined in the {@linkcode MARKDOWN_LINK_STOP_CHARACTERS}\n * The parser responsible for transitioning from a {@linkcode PartialMarkdownLinkCaption}\n * transitions into the {@linkcode MarkdownLink} token type which signifies the end of the entire\n * Otherwise, if one of the stop characters defined in the {@linkcode MARKDOWN_LINK_STOP_CHARACTERS}\n\t * See comment in the {@linkcode accept} method for more details.\nAfter:\n * into the {@link MarkdownLinkCaption} parser type which continues the general\n * Otherwise, if one of the stop characters defined in the {@link MARKDOWN_LINK_STOP_CHARACTERS}\n * The parser responsible for transitioning from a {@link PartialMarkdownLinkCaption}\n * transitions into the {@link MarkdownLink} token type which signifies the end of the entire\n * Otherwise, if one of the stop characters defined in the {@link MARKDOWN_LINK_STOP_CHARACTERS}\n\t * See comment in the {@link accept} method for more details.\n\nFile: src/vs/workbench/contrib/chat/browser/attachments/promptInstructions/promptInstructionsCollectionWidget.ts\nBefore:\n * See {@linkcode InstructionsAttachmentWidget}.\n\t * See {@linkcode onAttachmentsCountChange}.\n\tprivate _onAttachmentsCountChange = this._register(new Emitter<void>());\n\t * Subscribe to the `onAttachmentsCountChange` event.\n\tpublic onAttachmentsCountChange(callback: () => unknown): this {\n\t\tthis._register(this._onAttachmentsCountChange.event(callback));\n\t\t\tthis._onAttachmentsCountChange.fire();\n\t\tthis._onAttachmentsCountChange.fire();\nAfter:\n * See {@link InstructionsAttachmentWidget}.\n\t * See {@link onAttachmentsChange}.\n\tprivate _onAttachmentsChange = this._register(new Emitter<void>());\n\t * Subscribe to the `onAttachmentsChange` event.\n\tpublic onAttachmentsChange(callback: () => unknown): this {\n\t\tthis._register(this._on...[truncated]"
    },
    {
      "pr_number": 246914,
      "changes": "File: src/vs/workbench/contrib/chat/browser/actions/chatContextActions.ts\nBefore:\nimport { runAttachInstructionsAction } from './promptActions/index.js';\n\n\nAfter:\nimport { runAttachInstructionsAction, registerPromptActions } from './promptActions/index.js';\n\n/**\n * Register all actions related to reusable prompt files.\n */\nregisterPromptActions();\n\nFile: src/vs/workbench/contrib/chat/browser/actions/promptActions/dialogs/askToSelectPrompt/utils/runPrompt.ts\nBefore:\n\tawait widget.setInput(`/${basename(file)}`);\n\nAfter:\n\twidget.setInput(`/${basename(file)}`);\n\n\nFile: src/vs/workbench/contrib/chat/browser/actions/promptActions/index.ts\nBefore:\n\nexport { runAttachInstructionsAction } from './chatAttachInstructionsAction.js';\nAfter:\nexport { runAttachInstructionsAction } from './chatAttachInstructionsAction.js';\n\nFile: src/vs/workbench/contrib/chat/browser/attachments/promptInstructions/promptInstructionsCollectionWidget.ts\nAfter:\n\t/**\n\t * Get a promise that resolves when parsing/resolving processes\n\t * are fully completed, including all possible nested child references.\n\t */\n\tpublic allSettled() {\n\t\treturn this.model.allSettled();\n\t}\n\n\nFile: src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentModel.ts\nBefore:\n\t\tconst { errorCondition } = this.reference;\n\t\tthis._onUpdate.fire = this._onUpdate.fire.bind(this._onUpdate);\n\t\tthis._reference.onUpdate(this._onUpdate.fire);\nAfter:\n\t\tconst { errorCondition } = reference;\n\t/**\n\t * Get list of all tools associated with the prompt.\n\t *\n\t * Note! This property returns pont-in-time state of the tools metadata\n\t *       and does not take into account if the prompt or its nested child\n\t *       references are still being resolved. Please use the {@link settled}\n\t *       or {@link allSettled} properties if you need to retrieve the final\n\t *       list of the tools available.\n\t */\n\tpublic get toolsMetadata(): readonly string[] | null {\n\t\treturn this.reference.allToolsMetadata;\n\t}\n\n\t\tthis._reference.onUpdate(\n\t\t...[truncated]"
    }
  ],
  "pr_files": [
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatAttachPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/chatRunPromptAction.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/askToSelectPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/attachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/actions/reusablePromptActions/dialogs/askToSelectPrompt/utils/detachPrompt.ts",
    "src/vs/workbench/contrib/chat/browser/chatAttachmentModel/chatPromptAttachmentsCollection.ts"
  ]
}